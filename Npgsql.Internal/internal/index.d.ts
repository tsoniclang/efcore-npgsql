// Generated by tsbindgen - Architecture
// Namespace: Npgsql.Internal
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { DataTypeName, Field, PgTypeId } from "../../Npgsql.Internal.Postgres/internal/index.js";
import type { PostgresType } from "../../Npgsql.PostgresTypes/internal/index.js";
import type { NpgsqlTimeout } from "../../Npgsql.Util/internal/index.js";
import type { ArrayNullabilityMode, INpgsqlNameTranslator, NpgsqlBatch, NpgsqlCommand, NpgsqlConnectionStringBuilder } from "../../Npgsql/internal/index.js";
import type { NpgsqlRange_1 } from "../../NpgsqlTypes/internal/index.js";
import type { ReadOnlySequence } from "@tsonic/dotnet/System.Buffers.js";
import type { IEnumerable, IReadOnlyList, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbType } from "@tsonic/dotnet/System.Data.js";
import type { Stream, TextReader } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Double, Enum, Func, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory, MulticastDelegate, Nullable, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, Single, Span, String as ClrString, TimeSpan, Type, UInt16, UInt32, UInt64, ValueType, Version, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum DataFormat {
    Binary = 0,
    Text = 1
}


export enum MatchRequirement {
    All = 0,
    Single = 1,
    DataTypeName = 2
}


export enum SizeKind {
    Unknown = 0,
    Exact = 1,
    UpperBound = 2
}


export type TypeInfoFactory = (options: PgSerializerOptions, mapping: TypeInfoMapping, requiresDataTypeName: boolean) => PgTypeInfo;


export interface IDbTypeResolver$instance {
    GetDataTypeName(dbType: DbType, type: Type): string | undefined;
    GetDbType(dataTypeName: DataTypeName): Nullable<DbType>;
}


export type IDbTypeResolver = IDbTypeResolver$instance;

export interface INpgsqlDatabaseInfoFactory$instance {
    Load(conn: NpgsqlConnector, timeout: NpgsqlTimeout, async: boolean): Task<NpgsqlDatabaseInfo | undefined>;
}


export type INpgsqlDatabaseInfoFactory = INpgsqlDatabaseInfoFactory$instance;

export interface IPgTypeInfoResolver$instance {
    GetTypeInfo(type: Type, dataTypeName: Nullable<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export type IPgTypeInfoResolver = IPgTypeInfoResolver$instance;

export interface BufferRequirements$instance {
    readonly Read: Size;
    readonly Write: Size;
    Combine(read: Size, write: Size): BufferRequirements;
    Combine(other: BufferRequirements): BufferRequirements;
    Combine(byteCount: int): BufferRequirements;
    Equals(other: BufferRequirements): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const BufferRequirements: {
    new(): BufferRequirements;
    readonly None: BufferRequirements;
    readonly Value: BufferRequirements;
    Create(read: Size, write: Size): BufferRequirements;
    Create(value: Size): BufferRequirements;
    CreateFixedSize(byteCount: int): BufferRequirements;
};


export type BufferRequirements = BufferRequirements$instance;

export interface NestedReadScope$instance {
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const NestedReadScope: {
    new(): NestedReadScope;
};


export type NestedReadScope = NestedReadScope$instance;

export interface NestedWriteScope$instance {
    Dispose(): void;
}


export const NestedWriteScope: {
    new(): NestedWriteScope;
};


export type NestedWriteScope = NestedWriteScope$instance;

export interface PgConverterResolution$instance {
    readonly Converter: PgConverter;
    readonly PgTypeId: PgTypeId;
    GetConverter<T>(): PgConverter_1<T>;
}


export const PgConverterResolution: {
    new(converter: PgConverter, pgTypeId: PgTypeId): PgConverterResolution;
};


export type PgConverterResolution = PgConverterResolution$instance;

export interface Size$instance {
    readonly Kind: SizeKind;
    readonly Value: int;
    Combine(other: Size): Size;
    Equals(other: Size): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryCombine(other: Size, result: Size): boolean;
}


export const Size: {
    new(): Size;
    readonly Unknown: Size;
    readonly Zero: Size;
    Create(byteCount: int): Size;
    CreateUpperBound(byteCount: int): Size;
};


export type Size = Size$instance;

export interface SizeContext$instance {
    BufferRequirement: Size;
    readonly Format: DataFormat;
}


export const SizeContext: {
    new(format: DataFormat, bufferRequirement: Size): SizeContext;
};


export type SizeContext = SizeContext$instance;

export interface TypeInfoMapping$instance {
    DataTypeName: string;
    Factory: TypeInfoFactory;
    MatchRequirement: MatchRequirement;
    Type: Type;
    get TypeMatchPredicate(): Func<Type | undefined, System_Internal.Boolean> | undefined;
    set TypeMatchPredicate(value: Func<Type | undefined, System_Internal.Boolean>);
    DataTypeNameEquals(dataTypeName: string): boolean;
    TypeEquals(type: Type): boolean;
}


export const TypeInfoMapping: {
    new(type: Type, dataTypeName: string, factory: TypeInfoFactory): TypeInfoMapping;
};


export type TypeInfoMapping = TypeInfoMapping$instance;

export interface ValueMetadata$instance {
    BufferRequirement: Size;
    Format: DataFormat;
    Size: Size;
    get WriteState(): unknown | undefined;
    set WriteState(value: unknown);
}


export const ValueMetadata: {
    new(): ValueMetadata;
};


export type ValueMetadata = ValueMetadata$instance;

export interface DbTypeResolverFactory$instance {
    CreateDbTypeResolver(databaseInfo: NpgsqlDatabaseInfo): IDbTypeResolver;
}


export const DbTypeResolverFactory: {
};


export type DbTypeResolverFactory = DbTypeResolverFactory$instance;

export interface DynamicTypeInfoResolver$instance {
    GetTypeInfo(type: Type, dataTypeName: Nullable<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export const DynamicTypeInfoResolver: {
};


export interface __DynamicTypeInfoResolver$views {
    As_IPgTypeInfoResolver(): IPgTypeInfoResolver$instance;
}

export interface DynamicTypeInfoResolver$instance extends IPgTypeInfoResolver$instance {}

export type DynamicTypeInfoResolver = DynamicTypeInfoResolver$instance & __DynamicTypeInfoResolver$views;


export interface NpgsqlConnector$instance {
    readonly DatabaseInfo: NpgsqlDatabaseInfo;
    readonly Settings: NpgsqlConnectionStringBuilder;
    readonly TextEncoding: Encoding;
    CreateBatch(): NpgsqlBatch;
    CreateCommand(cmdText?: string): NpgsqlCommand;
}


export const NpgsqlConnector: {
    new(): NpgsqlConnector;
};


export type NpgsqlConnector = NpgsqlConnector$instance;

export interface NpgsqlDatabaseInfo$instance {
    readonly HasIntegerDateTimes: boolean;
    readonly Host: string;
    readonly Name: string;
    readonly Port: int;
    readonly ServerVersion: string;
    readonly SupportsAdvisoryLocks: boolean;
    readonly SupportsCloseAll: boolean;
    readonly SupportsDiscard: boolean;
    readonly SupportsDiscardSequences: boolean;
    readonly SupportsDiscardTemp: boolean;
    readonly SupportsEnumTypes: boolean;
    readonly SupportsMultirangeTypes: boolean;
    readonly SupportsRangeTypes: boolean;
    readonly SupportsTransactions: boolean;
    readonly SupportsUnlisten: boolean;
    readonly Version: Version;
    GetPostgresType(oid: uint): PostgresType;
    GetPostgresType(pgName: string): PostgresType;
    TryGetPostgresTypeByName(pgName: string, pgType: PostgresType): boolean;
}


export const NpgsqlDatabaseInfo: {
    RegisterFactory(factory: INpgsqlDatabaseInfoFactory): void;
};


export type NpgsqlDatabaseInfo = NpgsqlDatabaseInfo$instance;

export interface PgBufferedConverter_1$instance<T> extends PgConverter_1<T> {
    GetSize(context: SizeContext, value: T, writeState: unknown): Size;
    Read(reader: PgReader): T;
    ReadAsync(reader: PgReader, cancellationToken?: CancellationToken): ValueTask<T>;
    ReadAsync(reader: PgReader, cancellationToken?: CancellationToken): ValueTask<T>;
    Write(writer: PgWriter, value: T): void;
    WriteAsync(writer: PgWriter, value: T, cancellationToken?: CancellationToken): ValueTask;
}


export const PgBufferedConverter_1: {
};


export type PgBufferedConverter_1<T> = PgBufferedConverter_1$instance<T>;

export interface PgConverter$instance {
    readonly IsDbNullable: boolean;
    CanConvert(format: DataFormat, bufferRequirements: BufferRequirements): boolean;
}


export const PgConverter: {
};


export type PgConverter = PgConverter$instance;

export interface PgConverter_1$instance<T> extends PgConverter {
    GetSize(context: SizeContext, value: T, writeState: unknown): Size;
    IsDbNull(value: T, writeState: unknown): boolean;
    Read(reader: PgReader): T;
    ReadAsync(reader: PgReader, cancellationToken?: CancellationToken): ValueTask<T>;
    Write(writer: PgWriter, value: T): void;
    WriteAsync(writer: PgWriter, value: T, cancellationToken?: CancellationToken): ValueTask;
}


export const PgConverter_1: {
};


export type PgConverter_1<T> = PgConverter_1$instance<T>;

export interface PgConverterResolver$instance {
    Get(field: Field): PgConverterResolution;
    GetDefault(pgTypeId: Nullable<PgTypeId>): PgConverterResolution;
}


export const PgConverterResolver: {
};


export type PgConverterResolver = PgConverterResolver$instance;

export interface PgConverterResolver_1$instance<T> extends PgConverterResolver {
    Get(value: T, expectedPgTypeId: Nullable<PgTypeId>): Nullable<PgConverterResolution>;
    Get(field: Field): PgConverterResolution;
}


export const PgConverterResolver_1: {
};


export type PgConverterResolver_1<T> = PgConverterResolver_1$instance<T>;

export interface PgReader$instance {
    readonly Current: ValueMetadata;
    readonly CurrentRemaining: int;
    readonly IsResumed: boolean;
    BeginNestedRead(size: int, bufferRequirement: Size): NestedReadScope;
    BeginNestedReadAsync(size: int, bufferRequirement: Size, cancellationToken?: CancellationToken): ValueTask<NestedReadScope>;
    Buffer(bufferRequirement: Size): void;
    Buffer(byteCount: int): void;
    BufferAsync(bufferRequirement: Size, cancellationToken: CancellationToken): ValueTask;
    BufferAsync(byteCount: int, cancellationToken: CancellationToken): ValueTask;
    Consume(count?: Nullable<System_Internal.Int32>): void;
    ConsumeAsync(count?: Nullable<System_Internal.Int32>, cancellationToken?: CancellationToken): ValueTask;
    GetStream(length?: Nullable<System_Internal.Int32>): Stream;
    GetTextReader(encoding: Encoding): TextReader;
    GetTextReaderAsync(encoding: Encoding, cancellationToken: CancellationToken): ValueTask<TextReader>;
    Read(destination: Span<System_Internal.Byte>): void;
    ReadByte(): byte;
    ReadBytes(buffer: Span<System_Internal.Byte>): void;
    ReadBytes(count: int): ReadOnlySequence<System_Internal.Byte>;
    ReadBytesAsync(buffer: Memory<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    ReadBytesAsync(count: int, cancellationToken?: CancellationToken): ValueTask<ReadOnlySequence<System_Internal.Byte>>;
    ReadDouble(): double;
    ReadFloat(): float;
    ReadInt16(): short;
    ReadInt32(): int;
    ReadInt64(): long;
    ReadNullTerminatedString(encoding: Encoding): string;
    ReadNullTerminatedStringAsync(encoding: Encoding, cancellationToken?: CancellationToken): ValueTask<System_Internal.String>;
    ReadUInt16(): ushort;
    ReadUInt32(): uint;
    ReadUInt64(): ulong;
    Rewind(count: int): void;
    ShouldBuffer(bufferRequirement: Size): boolean;
    ShouldBuffer(byteCount: int): boolean;
    TryReadBytes(count: int, bytes: ReadOnlySpan<System_Internal.Byte>): boolean;
    TryReadBytes(count: int, bytes: ReadOnlyMemory<System_Internal.Byte>): boolean;
}


export const PgReader: {
    new(): PgReader;
};


export type PgReader = PgReader$instance;

export interface PgResolverTypeInfo$instance extends PgTypeInfo {
    GetConverterResolver(): PgConverterResolver;
    GetDefaultResolution(expectedPgTypeId: Nullable<PgTypeId>): PgConverterResolution;
    GetResolution<T>(value: T, expectedPgTypeId: Nullable<PgTypeId>): Nullable<PgConverterResolution>;
    GetResolution(field: Field): PgConverterResolution;
    GetResolution<T>(value: T): PgConverterResolution;
    GetResolutionAsObject(value: unknown, expectedPgTypeId: Nullable<PgTypeId>): Nullable<PgConverterResolution>;
}


export const PgResolverTypeInfo: {
    new(options: PgSerializerOptions, converterResolver: PgConverterResolver, pgTypeId: Nullable<PgTypeId>, unboxedType: Type): PgResolverTypeInfo;
};


export type PgResolverTypeInfo = PgResolverTypeInfo$instance;

export interface PgSerializerOptions$instance {
    ArrayNullabilityMode: ArrayNullabilityMode;
    DefaultNameTranslator: INpgsqlNameTranslator;
    EnableDateTimeInfinityConversions: boolean;
    TextEncoding: Encoding;
    readonly TimeZone: string;
    readonly TypeInfoResolver: IPgTypeInfoResolver;
    GetArrayElementTypeId(arrayTypeId: PgTypeId): PgTypeId;
    GetArrayTypeId(elementTypeId: PgTypeId): PgTypeId;
    GetDataTypeName(pgTypeId: PgTypeId): DataTypeName;
    GetDefaultTypeInfo(type: Type): PgTypeInfo | undefined;
    GetDefaultTypeInfo(pgTypeId: PgTypeId): PgTypeInfo | undefined;
    GetMultirangeElementTypeId(multirangeTypeId: PgTypeId): PgTypeId;
    GetMultirangeTypeId(rangeTypeId: PgTypeId): PgTypeId;
    GetRangeSubtypeTypeId(rangeTypeId: PgTypeId): PgTypeId;
    GetRangeTypeId(subtypeTypeId: PgTypeId): PgTypeId;
    GetTypeInfo(type: Type, pgTypeId: PgTypeId): PgTypeInfo | undefined;
    TryGetDataTypeName(pgTypeId: PgTypeId, dataTypeName: DataTypeName): boolean;
}


export const PgSerializerOptions: {
    new(): PgSerializerOptions;
    IsWellKnownTextType(type: Type): boolean;
};


export type PgSerializerOptions = PgSerializerOptions$instance;

export interface PgStreamingConverter_1$instance<T> extends PgConverter_1<T> {
    CanConvert(format: DataFormat, bufferRequirements: BufferRequirements): boolean;
}


export const PgStreamingConverter_1: {
};


export type PgStreamingConverter_1<T> = PgStreamingConverter_1$instance<T>;

export interface PgTypeInfo$instance {
    readonly Options: PgSerializerOptions;
    readonly PgTypeId: Nullable<PgTypeId>;
    PreferredFormat: Nullable<DataFormat>;
    SupportsReading: boolean;
    SupportsWriting: boolean;
    readonly Type: Type;
    GetBufferRequirements(converter: PgConverter, format: DataFormat): Nullable<BufferRequirements>;
    GetObjectResolution(value: unknown): PgConverterResolution;
    GetResolution<T>(value: T): PgConverterResolution;
}


export const PgTypeInfo: {
    new(options: PgSerializerOptions, converter: PgConverter, pgTypeId: PgTypeId, unboxedType: Type): PgTypeInfo;
};


export type PgTypeInfo = PgTypeInfo$instance;

export interface PgTypeInfoResolverFactory$instance {
    CreateArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateMultirangeArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateMultirangeResolver(): IPgTypeInfoResolver | undefined;
    CreateRangeArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateRangeResolver(): IPgTypeInfoResolver | undefined;
    CreateResolver(): IPgTypeInfoResolver;
}


export const PgTypeInfoResolverFactory: {
};


export type PgTypeInfoResolverFactory = PgTypeInfoResolverFactory$instance;

export interface PgWriter$instance {
    readonly Current: ValueMetadata;
    BeginNestedWrite(bufferRequirement: Size, byteCount: int, state: unknown): NestedWriteScope;
    BeginNestedWriteAsync(bufferRequirement: Size, byteCount: int, state: unknown, cancellationToken?: CancellationToken): ValueTask<NestedWriteScope>;
    Flush(timeout?: TimeSpan): void;
    FlushAsync(cancellationToken?: CancellationToken): ValueTask;
    GetStream(allowMixedIO?: boolean): Stream;
    ShouldFlush(bufferRequirement: Size): boolean;
    ShouldFlush(byteCount: int): boolean;
    WriteAsOid(pgTypeId: PgTypeId): void;
    WriteByte(value: byte): void;
    WriteBytes(buffer: ReadOnlySpan<System_Internal.Byte>): void;
    WriteBytesAsync(buffer: ReadOnlyMemory<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteChars(data: ReadOnlySpan<System_Internal.Char>, encoding: Encoding): void;
    WriteCharsAsync(data: ReadOnlyMemory<System_Internal.Char>, encoding: Encoding, cancellationToken?: CancellationToken): ValueTask;
    WriteDouble(value: double): void;
    WriteFloat(value: float): void;
    WriteInt16(value: short): void;
    WriteInt32(value: int): void;
    WriteInt64(value: long): void;
    WriteUInt16(value: ushort): void;
    WriteUInt32(value: uint): void;
    WriteUInt64(value: ulong): void;
}


export const PgWriter: {
    new(): PgWriter;
};


export type PgWriter = PgWriter$instance;

export interface TypeInfoMappingCollection$instance {
    readonly Items: IReadOnlyList<TypeInfoMapping>;
    Add(mapping: TypeInfoMapping): void;
    AddArrayType<TElement>(elementDataTypeName: string): void;
    AddArrayType<TElement>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddArrayType<TElement>(elementMapping: TypeInfoMapping): void;
    AddArrayType<TElement>(elementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddPolymorphicResolverArrayType(elementDataTypeName: string, elementToArrayConverterFactory: Func<PgSerializerOptions, Func<PgConverterResolution, PgConverter>>): void;
    AddPolymorphicResolverArrayType(elementMapping: TypeInfoMapping, elementToArrayConverterFactory: Func<PgSerializerOptions, Func<PgConverterResolution, PgConverter>>): void;
    AddRange(collection: TypeInfoMappingCollection): void;
    AddResolverArrayType<TElement>(elementDataTypeName: string): void;
    AddResolverArrayType<TElement>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddResolverArrayType<TElement>(elementMapping: TypeInfoMapping): void;
    AddResolverArrayType<TElement>(elementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddResolverStructArrayType<TElement extends unknown>(elementDataTypeName: string): void;
    AddResolverStructArrayType<TElement extends unknown>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddResolverStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping): void;
    AddResolverStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func<TypeInfoMapping, TypeInfoMapping>): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func<TypeInfoMapping, TypeInfoMapping>): void;
    AddStructArrayType<TElement extends unknown>(elementDataTypeName: string): void;
    AddStructArrayType<TElement extends unknown>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping): void;
    AddStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func<TypeInfoMapping, TypeInfoMapping>): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func<TypeInfoMapping, TypeInfoMapping>): void;
    Find(type: Type, dataTypeName: Nullable<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export const TypeInfoMappingCollection: {
    new(capacity: int): TypeInfoMappingCollection;
    new(): TypeInfoMappingCollection;
    new(baseCollection: TypeInfoMappingCollection): TypeInfoMappingCollection;
    new(items: IEnumerable<TypeInfoMapping>): TypeInfoMappingCollection;
    IsArrayLikeType(type: Type, elementType: Type): boolean;
};


export type TypeInfoMappingCollection = TypeInfoMappingCollection$instance;

export abstract class PgConverterFactory$instance {
    static CreateArrayMultirangeConverter<T>(rangeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<T[]>;
    static CreateListMultirangeConverter<T>(rangeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<List<T>>;
    static CreatePolymorphicArrayConverter<TBase>(arrayConverterFactory: Func<PgConverter_1<TBase>>, nullableArrayConverterFactory: Func<PgConverter_1<TBase>>, options: PgSerializerOptions): PgConverter_1<TBase>;
    static CreateRangeConverter<T>(subTypeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<NpgsqlRange_1<T>>;
}


export type PgConverterFactory = PgConverterFactory$instance;

export abstract class TypeInfoMappingHelpers$instance {
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, converter: PgConverter, preferredFormat?: Nullable<DataFormat>, supportsWriting?: boolean): PgTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, converter: PgConverter): PgTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, resolver: PgConverterResolver, includeDataTypeName: boolean, preferredFormat?: Nullable<DataFormat>, supportsWriting?: boolean): PgResolverTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, resolver: PgConverterResolver, includeDataTypeName: boolean): PgResolverTypeInfo;
}


export type TypeInfoMappingHelpers = TypeInfoMappingHelpers$instance;

