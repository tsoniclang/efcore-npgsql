// Generated by tsbindgen - Architecture
// Namespace: Npgsql.Internal
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { DataTypeName, Field, PgTypeId } from "../../Npgsql.Internal.Postgres/internal/index.js";
import type { PostgresType } from "../../Npgsql.PostgresTypes/internal/index.js";
import type { NpgsqlTimeout } from "../../Npgsql.Util/internal/index.js";
import type { ArrayNullabilityMode, INpgsqlNameTranslator, NpgsqlBatch, NpgsqlCommand, NpgsqlConnectionStringBuilder } from "../../Npgsql/internal/index.js";
import type { NpgsqlRange_1 } from "../../NpgsqlTypes/internal/index.js";
import type { ReadOnlySequence_1 } from "@tsonic/dotnet/System.Buffers/internal/index.js";
import type { IEnumerable_1, IReadOnlyList_1, List_1 } from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import type { DbType } from "@tsonic/dotnet/System.Data/internal/index.js";
import type { Stream, TextReader } from "@tsonic/dotnet/System.IO/internal/index.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { Encoding } from "@tsonic/dotnet/System.Text/internal/index.js";
import type { Task_1, ValueTask, ValueTask_1 } from "@tsonic/dotnet/System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System/internal/index.js";
import type { ArgumentOutOfRangeException, AsyncCallback, Boolean as ClrBoolean, Byte, Char, Double, Enum, Func_1, Func_2, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Single, Span_1, String as ClrString, TimeSpan, Type, UInt16, UInt32, UInt64, ValueType, Version, Void } from "@tsonic/dotnet/System/internal/index.js";

export enum DataFormat {
    Binary = 0,
    Text = 1
}


export enum MatchRequirement {
    All = 0,
    Single = 1,
    DataTypeName = 2
}


export enum SizeKind {
    Unknown = 0,
    Exact = 1,
    UpperBound = 2
}


export type TypeInfoFactory = (options: PgSerializerOptions, mapping: TypeInfoMapping, requiresDataTypeName: boolean) => PgTypeInfo;


export interface IDbTypeResolver$instance {
    readonly __tsonic_iface_Npgsql_Internal_IDbTypeResolver: never;

    GetDataTypeName(dbType: DbType, type: Type): string | undefined;
    GetDbType(dataTypeName: DataTypeName): Nullable_1<DbType>;
}


export type IDbTypeResolver = IDbTypeResolver$instance;

export interface INpgsqlDatabaseInfoFactory$instance {
    readonly __tsonic_iface_Npgsql_Internal_INpgsqlDatabaseInfoFactory: never;

    Load(conn: NpgsqlConnector, timeout: NpgsqlTimeout, async: boolean): Task_1<NpgsqlDatabaseInfo | undefined>;
}


export type INpgsqlDatabaseInfoFactory = INpgsqlDatabaseInfoFactory$instance;

export interface IPgTypeInfoResolver$instance {
    readonly __tsonic_iface_Npgsql_Internal_IPgTypeInfoResolver: never;

    GetTypeInfo(type: Type, dataTypeName: Nullable_1<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export type IPgTypeInfoResolver = IPgTypeInfoResolver$instance;

export interface BufferRequirements$instance {
    readonly __tsonic_type_Npgsql_Internal_BufferRequirements: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Read: Size;
    readonly Write: Size;
    Combine(read: Size, write: Size): BufferRequirements;
    Combine(other: BufferRequirements): BufferRequirements;
    Combine(byteCount: int): BufferRequirements;
    Equals(other: BufferRequirements): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const BufferRequirements: {
    new(): BufferRequirements;
    readonly None: BufferRequirements;
    readonly Value: BufferRequirements;
    Create(read: Size, write: Size): BufferRequirements;
    Create(value: Size): BufferRequirements;
    CreateFixedSize(byteCount: int): BufferRequirements;
};


export type BufferRequirements = BufferRequirements$instance;

export interface NestedReadScope$instance {
    readonly __tsonic_type_Npgsql_Internal_NestedReadScope: never;

    readonly __tsonic_iface_System_IAsyncDisposable: never;
    readonly __tsonic_iface_System_IDisposable: never;

    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const NestedReadScope: {
    new(): NestedReadScope;
};


export type NestedReadScope = NestedReadScope$instance;

export interface NestedWriteScope$instance {
    readonly __tsonic_type_Npgsql_Internal_NestedWriteScope: never;

    readonly __tsonic_iface_System_IDisposable: never;

    Dispose(): void;
}


export const NestedWriteScope: {
    new(): NestedWriteScope;
};


export type NestedWriteScope = NestedWriteScope$instance;

export interface PgConverterResolution$instance {
    readonly __tsonic_type_Npgsql_Internal_PgConverterResolution: never;

    readonly Converter: PgConverter;
    readonly PgTypeId: PgTypeId;
    GetConverter<T>(): PgConverter_1<T>;
}


export const PgConverterResolution: {
    new(converter: PgConverter, pgTypeId: PgTypeId): PgConverterResolution;
};


export type PgConverterResolution = PgConverterResolution$instance;

export interface Size$instance {
    readonly __tsonic_type_Npgsql_Internal_Size: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Kind: SizeKind;
    readonly Value: int;
    Combine(other: Size): Size;
    Equals(other: Size): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryCombine(other: Size, result: Size): boolean;
}


export const Size: {
    new(): Size;
    readonly Unknown: Size;
    readonly Zero: Size;
    Create(byteCount: int): Size;
    CreateUpperBound(byteCount: int): Size;
};


export type Size = Size$instance;

export interface SizeContext$instance {
    readonly __tsonic_type_Npgsql_Internal_SizeContext: never;

    BufferRequirement: Size;
    readonly Format: DataFormat;
}


export const SizeContext: {
    new(format: DataFormat, bufferRequirement: Size): SizeContext;
};


export type SizeContext = SizeContext$instance;

export interface TypeInfoMapping$instance {
    readonly __tsonic_type_Npgsql_Internal_TypeInfoMapping: never;

    DataTypeName: string;
    Factory: TypeInfoFactory;
    MatchRequirement: MatchRequirement;
    Type: Type;
    get TypeMatchPredicate(): Func_2<Type | undefined, System_Internal.Boolean> | undefined;
    set TypeMatchPredicate(value: Func_2<Type | undefined, System_Internal.Boolean> | undefined);
    DataTypeNameEquals(dataTypeName: string): boolean;
    TypeEquals(type: Type): boolean;
}


export const TypeInfoMapping: {
    new(type: Type, dataTypeName: string, factory: TypeInfoFactory): TypeInfoMapping;
};


export type TypeInfoMapping = TypeInfoMapping$instance;

export interface ValueMetadata$instance {
    readonly __tsonic_type_Npgsql_Internal_ValueMetadata: never;

    BufferRequirement: Size;
    Format: DataFormat;
    Size: Size;
    get WriteState(): unknown | undefined;
    set WriteState(value: unknown | undefined);
}


export const ValueMetadata: {
    new(): ValueMetadata;
};


export type ValueMetadata = ValueMetadata$instance;

export interface DbTypeResolverFactory$instance {
    readonly __tsonic_type_Npgsql_Internal_DbTypeResolverFactory: never;

    CreateDbTypeResolver(databaseInfo: NpgsqlDatabaseInfo): IDbTypeResolver;
}


export const DbTypeResolverFactory: (abstract new() => DbTypeResolverFactory) & {
};


export type DbTypeResolverFactory = DbTypeResolverFactory$instance;

export interface DynamicTypeInfoResolver$instance extends IPgTypeInfoResolver$instance {
    readonly __tsonic_type_Npgsql_Internal_DynamicTypeInfoResolver: never;

    readonly __tsonic_iface_Npgsql_Internal_IPgTypeInfoResolver: never;

    GetMappings(type: Type, dataTypeName: DataTypeName, options: PgSerializerOptions): unknown | undefined;
    GetTypeInfo(type: Type, dataTypeName: Nullable_1<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export const DynamicTypeInfoResolver: (abstract new() => DynamicTypeInfoResolver) & {
    CreateCollection(baseCollection?: TypeInfoMappingCollection): unknown;
    IsArrayDataTypeName(dataTypeName: DataTypeName, options: PgSerializerOptions, elementDataTypeName: DataTypeName): boolean;
    IsArrayLikeType(type: Type, elementType: Type): boolean;
    IsTypeOrNullableOfType(type: Type, predicate: Func_2<Type, System_Internal.Boolean>, matchedType: Type): boolean;
};


export interface __DynamicTypeInfoResolver$views {
    As_IPgTypeInfoResolver(): IPgTypeInfoResolver$instance;
}

export type DynamicTypeInfoResolver = DynamicTypeInfoResolver$instance & __DynamicTypeInfoResolver$views;


export interface NpgsqlConnector$instance {
    readonly __tsonic_type_Npgsql_Internal_NpgsqlConnector: never;

    readonly DatabaseInfo: NpgsqlDatabaseInfo;
    readonly Settings: NpgsqlConnectionStringBuilder;
    TextEncoding: Encoding;
    CreateBatch(): NpgsqlBatch;
    CreateCommand(cmdText?: string): NpgsqlCommand;
}


export const NpgsqlConnector: {
};


export type NpgsqlConnector = NpgsqlConnector$instance;

export interface NpgsqlDatabaseInfo$instance {
    readonly __tsonic_type_Npgsql_Internal_NpgsqlDatabaseInfo: never;

    HasIntegerDateTimes: boolean;
    readonly Host: string;
    readonly Name: string;
    readonly Port: int;
    readonly ServerVersion: string;
    readonly SupportsAdvisoryLocks: boolean;
    readonly SupportsCloseAll: boolean;
    readonly SupportsDiscard: boolean;
    readonly SupportsDiscardSequences: boolean;
    readonly SupportsDiscardTemp: boolean;
    readonly SupportsEnumTypes: boolean;
    readonly SupportsMultirangeTypes: boolean;
    readonly SupportsRangeTypes: boolean;
    SupportsTransactions: boolean;
    readonly SupportsUnlisten: boolean;
    readonly Version: Version;
    GetPostgresType(oid: uint): PostgresType;
    GetPostgresType(pgName: string): PostgresType;
    GetTypes(): IEnumerable_1<PostgresType>;
    TryGetPostgresTypeByName(pgName: string, pgType: PostgresType): boolean;
}


export const NpgsqlDatabaseInfo: (abstract new(host: string, port: int, databaseName: string, version: Version) => NpgsqlDatabaseInfo) & (abstract new(host: string, port: int, databaseName: string, version: Version, serverVersion: string) => NpgsqlDatabaseInfo) & {
    ParseServerVersion(value: string): Version;
    RegisterFactory(factory: INpgsqlDatabaseInfoFactory): void;
};


export type NpgsqlDatabaseInfo = NpgsqlDatabaseInfo$instance;

export interface PgBufferedConverter_1$instance<T> extends PgConverter_1<T> {
    readonly __tsonic_type_Npgsql_Internal_PgBufferedConverter_1: never;

    GetSize(context: SizeContext, value: T, writeState: unknown): Size;
    Read(reader: PgReader): T;
    ReadAsync(reader: PgReader, cancellationToken?: CancellationToken): ValueTask_1<T>;
    ReadCore(reader: PgReader): T;
    Write(writer: PgWriter, value: T): void;
    WriteAsync(writer: PgWriter, value: T, cancellationToken?: CancellationToken): ValueTask;
    WriteCore(writer: PgWriter, value: T): void;
}


export const PgBufferedConverter_1: (abstract new<T>(customDbNullPredicate: boolean) => PgBufferedConverter_1<T>) & {
};


export type PgBufferedConverter_1<T> = PgBufferedConverter_1$instance<T>;

export interface PgConverter$instance {
    readonly __tsonic_type_Npgsql_Internal_PgConverter: never;

    readonly IsDbNullable: boolean;
    CanConvert(format: DataFormat, bufferRequirements: BufferRequirements): boolean;
}


export const PgConverter: {
};


export type PgConverter = PgConverter$instance;

export interface PgConverter_1$instance<T> extends PgConverter {
    readonly __tsonic_type_Npgsql_Internal_PgConverter_1: never;

    GetSize(context: SizeContext, value: T, writeState: unknown): Size;
    IsDbNull(value: T, writeState: unknown): boolean;
    IsDbNullValue(value: T, writeState: unknown): boolean;
    Read(reader: PgReader): T;
    ReadAsync(reader: PgReader, cancellationToken?: CancellationToken): ValueTask_1<T>;
    Write(writer: PgWriter, value: T): void;
    WriteAsync(writer: PgWriter, value: T, cancellationToken?: CancellationToken): ValueTask;
}


export const PgConverter_1: {
};


export type PgConverter_1<T> = PgConverter_1$instance<T>;

export interface PgConverterResolver$instance {
    readonly __tsonic_type_Npgsql_Internal_PgConverterResolver: never;

    Get(field: Field): PgConverterResolution;
    GetDefault(pgTypeId: Nullable_1<PgTypeId>): PgConverterResolution;
}


export const PgConverterResolver: {
};


export type PgConverterResolver = PgConverterResolver$instance;

export interface PgConverterResolver_1$instance<T> extends PgConverterResolver {
    readonly __tsonic_type_Npgsql_Internal_PgConverterResolver_1: never;

    Get(value: T, expectedPgTypeId: Nullable_1<PgTypeId>): Nullable_1<PgConverterResolution>;
    Get(field: Field): PgConverterResolution;
}


export const PgConverterResolver_1: (abstract new<T>() => PgConverterResolver_1<T>) & {
};


export type PgConverterResolver_1<T> = PgConverterResolver_1$instance<T>;

export interface PgReader$instance {
    readonly __tsonic_type_Npgsql_Internal_PgReader: never;

    readonly Current: ValueMetadata;
    readonly CurrentRemaining: int;
    readonly IsResumed: boolean;
    BeginNestedRead(size: int, bufferRequirement: Size): NestedReadScope;
    BeginNestedReadAsync(size: int, bufferRequirement: Size, cancellationToken?: CancellationToken): ValueTask_1<NestedReadScope>;
    Buffer(bufferRequirement: Size): void;
    Buffer(byteCount: int): void;
    BufferAsync(bufferRequirement: Size, cancellationToken: CancellationToken): ValueTask;
    BufferAsync(byteCount: int, cancellationToken: CancellationToken): ValueTask;
    Consume(count?: Nullable_1<System_Internal.Int32>): void;
    ConsumeAsync(count?: Nullable_1<System_Internal.Int32>, cancellationToken?: CancellationToken): ValueTask;
    GetStream(length?: Nullable_1<System_Internal.Int32>): Stream;
    GetTextReader(encoding: Encoding): TextReader;
    GetTextReaderAsync(encoding: Encoding, cancellationToken: CancellationToken): ValueTask_1<TextReader>;
    Read(destination: Span_1<System_Internal.Byte>): void;
    ReadByte(): byte;
    ReadBytes(buffer: Span_1<System_Internal.Byte>): void;
    ReadBytes(count: int): ReadOnlySequence_1<System_Internal.Byte>;
    ReadBytesAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    ReadBytesAsync(count: int, cancellationToken?: CancellationToken): ValueTask_1<ReadOnlySequence_1<System_Internal.Byte>>;
    ReadDouble(): double;
    ReadFloat(): float;
    ReadInt16(): short;
    ReadInt32(): int;
    ReadInt64(): long;
    ReadNullTerminatedString(encoding: Encoding): string;
    ReadNullTerminatedStringAsync(encoding: Encoding, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadUInt16(): ushort;
    ReadUInt32(): uint;
    ReadUInt64(): ulong;
    Rewind(count: int): void;
    ShouldBuffer(bufferRequirement: Size): boolean;
    ShouldBuffer(byteCount: int): boolean;
    TryReadBytes(count: int, bytes: ReadOnlySpan_1<System_Internal.Byte>): boolean;
    TryReadBytes(count: int, bytes: ReadOnlyMemory_1<System_Internal.Byte>): boolean;
}


export const PgReader: {
};


export type PgReader = PgReader$instance;

export interface PgResolverTypeInfo$instance extends PgTypeInfo {
    readonly __tsonic_type_Npgsql_Internal_PgResolverTypeInfo: never;

    GetConverterResolver(): PgConverterResolver;
    GetDefaultResolution(expectedPgTypeId: Nullable_1<PgTypeId>): PgConverterResolution;
    GetResolution<T>(value: T, expectedPgTypeId: Nullable_1<PgTypeId>): Nullable_1<PgConverterResolution>;
    GetResolution(field: Field): PgConverterResolution;
    GetResolution<T>(value: T): PgConverterResolution;
    GetResolutionAsObject(value: unknown, expectedPgTypeId: Nullable_1<PgTypeId>): Nullable_1<PgConverterResolution>;
}


export const PgResolverTypeInfo: {
    new(options: PgSerializerOptions, converterResolver: PgConverterResolver, pgTypeId: Nullable_1<PgTypeId>, unboxedType: Type): PgResolverTypeInfo;
};


export type PgResolverTypeInfo = PgResolverTypeInfo$instance;

export interface PgSerializerOptions$instance {
    readonly __tsonic_type_Npgsql_Internal_PgSerializerOptions: never;

    ArrayNullabilityMode: ArrayNullabilityMode;
    DefaultNameTranslator: INpgsqlNameTranslator;
    EnableDateTimeInfinityConversions: boolean;
    TextEncoding: Encoding;
    readonly TimeZone: string;
    TypeInfoResolver: IPgTypeInfoResolver;
    GetArrayElementTypeId(arrayTypeId: PgTypeId): PgTypeId;
    GetArrayTypeId(elementTypeId: PgTypeId): PgTypeId;
    GetDataTypeName(pgTypeId: PgTypeId): DataTypeName;
    GetDefaultTypeInfo(type: Type): PgTypeInfo | undefined;
    GetDefaultTypeInfo(pgTypeId: PgTypeId): PgTypeInfo | undefined;
    GetMultirangeElementTypeId(multirangeTypeId: PgTypeId): PgTypeId;
    GetMultirangeTypeId(rangeTypeId: PgTypeId): PgTypeId;
    GetRangeSubtypeTypeId(rangeTypeId: PgTypeId): PgTypeId;
    GetRangeTypeId(subtypeTypeId: PgTypeId): PgTypeId;
    GetTypeInfo(type: Type, pgTypeId: PgTypeId): PgTypeInfo | undefined;
    TryGetDataTypeName(pgTypeId: PgTypeId, dataTypeName: DataTypeName): boolean;
}


export const PgSerializerOptions: {
    IsWellKnownTextType(type: Type): boolean;
};


export type PgSerializerOptions = PgSerializerOptions$instance;

export interface PgStreamingConverter_1$instance<T> extends PgConverter_1<T> {
    readonly __tsonic_type_Npgsql_Internal_PgStreamingConverter_1: never;

    CanConvert(format: DataFormat, bufferRequirements: BufferRequirements): boolean;
}


export const PgStreamingConverter_1: (abstract new<T>(customDbNullPredicate: boolean) => PgStreamingConverter_1<T>) & {
};


export type PgStreamingConverter_1<T> = PgStreamingConverter_1$instance<T>;

export interface PgTypeInfo$instance {
    readonly __tsonic_type_Npgsql_Internal_PgTypeInfo: never;

    readonly Options: PgSerializerOptions;
    readonly PgTypeId: Nullable_1<PgTypeId>;
    PreferredFormat: Nullable_1<DataFormat>;
    SupportsReading: boolean;
    SupportsWriting: boolean;
    readonly Type: Type;
    GetBufferRequirements(converter: PgConverter, format: DataFormat): Nullable_1<BufferRequirements>;
    GetObjectResolution(value: unknown): PgConverterResolution;
    GetResolution<T>(value: T): PgConverterResolution;
}


export const PgTypeInfo: {
    new(options: PgSerializerOptions, converter: PgConverter, pgTypeId: PgTypeId, unboxedType: Type): PgTypeInfo;
};


export type PgTypeInfo = PgTypeInfo$instance;

export interface PgTypeInfoResolverFactory$instance {
    readonly __tsonic_type_Npgsql_Internal_PgTypeInfoResolverFactory: never;

    CreateArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateMultirangeArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateMultirangeResolver(): IPgTypeInfoResolver | undefined;
    CreateRangeArrayResolver(): IPgTypeInfoResolver | undefined;
    CreateRangeResolver(): IPgTypeInfoResolver | undefined;
    CreateResolver(): IPgTypeInfoResolver;
}


export const PgTypeInfoResolverFactory: (abstract new() => PgTypeInfoResolverFactory) & {
};


export type PgTypeInfoResolverFactory = PgTypeInfoResolverFactory$instance;

export interface PgWriter$instance {
    readonly __tsonic_type_Npgsql_Internal_PgWriter: never;

    readonly Current: ValueMetadata;
    BeginNestedWrite(bufferRequirement: Size, byteCount: int, state: unknown): NestedWriteScope;
    BeginNestedWriteAsync(bufferRequirement: Size, byteCount: int, state: unknown, cancellationToken?: CancellationToken): ValueTask_1<NestedWriteScope>;
    Flush(timeout?: TimeSpan): void;
    FlushAsync(cancellationToken?: CancellationToken): ValueTask;
    GetStream(allowMixedIO?: boolean): Stream;
    ShouldFlush(bufferRequirement: Size): boolean;
    ShouldFlush(byteCount: int): boolean;
    WriteAsOid(pgTypeId: PgTypeId): void;
    WriteByte(value: byte): void;
    WriteBytes(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteBytesAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteChars(data: ReadOnlySpan_1<System_Internal.Char>, encoding: Encoding): void;
    WriteCharsAsync(data: ReadOnlyMemory_1<System_Internal.Char>, encoding: Encoding, cancellationToken?: CancellationToken): ValueTask;
    WriteDouble(value: double): void;
    WriteFloat(value: float): void;
    WriteInt16(value: short): void;
    WriteInt32(value: int): void;
    WriteInt64(value: long): void;
    WriteUInt16(value: ushort): void;
    WriteUInt32(value: uint): void;
    WriteUInt64(value: ulong): void;
}


export const PgWriter: {
};


export type PgWriter = PgWriter$instance;

export interface TypeInfoMappingCollection$instance {
    readonly __tsonic_type_Npgsql_Internal_TypeInfoMappingCollection: never;

    readonly Items: IReadOnlyList_1<TypeInfoMapping>;
    Add(mapping: TypeInfoMapping): void;
    AddArrayType<TElement>(elementDataTypeName: string): void;
    AddArrayType<TElement>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddArrayType<TElement>(elementMapping: TypeInfoMapping): void;
    AddArrayType<TElement>(elementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddPolymorphicResolverArrayType(elementDataTypeName: string, elementToArrayConverterFactory: Func_2<PgSerializerOptions, Func_2<PgConverterResolution, PgConverter>>): void;
    AddPolymorphicResolverArrayType(elementMapping: TypeInfoMapping, elementToArrayConverterFactory: Func_2<PgSerializerOptions, Func_2<PgConverterResolution, PgConverter>>): void;
    AddRange(collection: TypeInfoMappingCollection): void;
    AddResolverArrayType<TElement>(elementDataTypeName: string): void;
    AddResolverArrayType<TElement>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddResolverArrayType<TElement>(elementMapping: TypeInfoMapping): void;
    AddResolverArrayType<TElement>(elementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddResolverStructArrayType<TElement extends unknown>(elementDataTypeName: string): void;
    AddResolverStructArrayType<TElement extends unknown>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddResolverStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping): void;
    AddResolverStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddResolverStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func_2<TypeInfoMapping, TypeInfoMapping>): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddResolverType<T>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func_2<TypeInfoMapping, TypeInfoMapping>): void;
    AddStructArrayType<TElement extends unknown>(elementDataTypeName: string): void;
    AddStructArrayType<TElement extends unknown>(elementDataTypeName: string, suppressObjectMapping: boolean): void;
    AddStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping): void;
    AddStructArrayType<TElement extends unknown>(elementMapping: TypeInfoMapping, nullableElementMapping: TypeInfoMapping, suppressObjectMapping: boolean): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddStructType<T extends unknown>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func_2<TypeInfoMapping, TypeInfoMapping>): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, isDefault?: boolean): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, matchRequirement: MatchRequirement): void;
    AddType<T>(dataTypeName: string, createInfo: TypeInfoFactory, configure: Func_2<TypeInfoMapping, TypeInfoMapping>): void;
    Find(type: Type, dataTypeName: Nullable_1<DataTypeName>, options: PgSerializerOptions): PgTypeInfo | undefined;
}


export const TypeInfoMappingCollection: {
    new(capacity: int): TypeInfoMappingCollection;
    new(): TypeInfoMappingCollection;
    new(baseCollection: TypeInfoMappingCollection): TypeInfoMappingCollection;
    new(items: IEnumerable_1<TypeInfoMapping>): TypeInfoMappingCollection;
    IsArrayLikeType(type: Type, elementType: Type): boolean;
};


export type TypeInfoMappingCollection = TypeInfoMappingCollection$instance;

export abstract class PgConverterFactory$instance {
    static CreateArrayMultirangeConverter<T>(rangeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<T[]>;
    static CreateListMultirangeConverter<T>(rangeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<List_1<T>>;
    static CreatePolymorphicArrayConverter<TBase>(arrayConverterFactory: Func_1<PgConverter_1<TBase>>, nullableArrayConverterFactory: Func_1<PgConverter_1<TBase>>, options: PgSerializerOptions): PgConverter_1<TBase>;
    static CreateRangeConverter<T>(subTypeConverter: PgConverter_1<T>, options: PgSerializerOptions): PgConverter_1<NpgsqlRange_1<T>>;
}


export type PgConverterFactory = PgConverterFactory$instance;

export abstract class TypeInfoMappingHelpers$instance {
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, converter: PgConverter, preferredFormat?: Nullable_1<DataFormat>, supportsWriting?: boolean): PgTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, converter: PgConverter): PgTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, resolver: PgConverterResolver, includeDataTypeName: boolean, preferredFormat?: Nullable_1<DataFormat>, supportsWriting?: boolean): PgResolverTypeInfo;
    static CreateInfo(mapping: TypeInfoMapping, options: PgSerializerOptions, resolver: PgConverterResolver, includeDataTypeName: boolean): PgResolverTypeInfo;
}


export type TypeInfoMappingHelpers = TypeInfoMappingHelpers$instance;

