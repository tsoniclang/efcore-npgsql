// Generated by tsbindgen - Architecture
// Namespace: Npgsql.EntityFrameworkCore.PostgreSQL.Query
// Assembly: Npgsql.EntityFrameworkCore.PostgreSQL

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { PgAllExpression, PgAllOperatorType, PgAnyExpression, PgAnyOperatorType, PgArrayIndexExpression, PgArraySliceExpression, PgFunctionExpression, PgILikeExpression, PgJsonTraversalExpression, PgNewArrayExpression, PgRegexMatchExpression } from "../../Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions.Internal/internal/index.js";
import type { PgExpressionType } from "../../Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions/internal/index.js";
import type { IEnumerable, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Boolean as ClrBoolean, String as ClrString, Type } from "@tsonic/dotnet/System.js";
import type { ExpressionType } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { RegexOptions } from "@tsonic/dotnet/System.Text.RegularExpressions.js";
import * as Microsoft_EntityFrameworkCore_Query_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import type { EnumerableExpression, ISqlExpressionFactory, SqlExpressionFactory, SqlExpressionFactoryDependencies } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import type { AtTimeZoneExpression, SqlExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { RelationalTypeMapping } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Storage.js";

export interface NpgsqlSqlExpressionFactory$instance extends SqlExpressionFactory {
    aggregateFunction(name: string, arguments: IEnumerable<SqlExpression>, aggregateEnumerableExpression: EnumerableExpression, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): PgFunctionExpression;
    all(item: SqlExpression, array: SqlExpression, operatorType: PgAllOperatorType): PgAllExpression;
    any_(item: SqlExpression, array: SqlExpression, operatorType: PgAnyOperatorType): PgAnyExpression;
    applyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
    arrayIndex(array: SqlExpression, index: SqlExpression, nullable: boolean, typeMapping?: RelationalTypeMapping): PgArrayIndexExpression;
    arraySlice(array: SqlExpression, lowerBound: SqlExpression, upperBound: SqlExpression, nullable: boolean, typeMapping?: RelationalTypeMapping): PgArraySliceExpression;
    atTimeZone(timestamp: SqlExpression, timeZone: SqlExpression, type_: Type, typeMapping?: RelationalTypeMapping): AtTimeZoneExpression;
    atUtc(timestamp: SqlExpression, typeMapping?: RelationalTypeMapping): AtTimeZoneExpression;
    containedBy(left: SqlExpression, right: SqlExpression): SqlExpression;
    contains(left: SqlExpression, right: SqlExpression): SqlExpression;
    generateOneBasedIndexExpression(expression: SqlExpression): SqlExpression;
    iLike(match: SqlExpression, pattern: SqlExpression, escapeChar?: SqlExpression): PgILikeExpression;
    jsonTraversal(expression: SqlExpression, returnsText: boolean, type_: Type, typeMapping?: RelationalTypeMapping): PgJsonTraversalExpression;
    jsonTraversal(expression: SqlExpression, path: IEnumerable<SqlExpression>, returnsText: boolean, type_: Type, typeMapping?: RelationalTypeMapping): PgJsonTraversalExpression;
    makeBinary(operatorType: ExpressionType, left: SqlExpression, right: SqlExpression, typeMapping: RelationalTypeMapping, existingExpr?: SqlExpression): SqlExpression | undefined;
    makePostgresBinary(operatorType: PgExpressionType, left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    newArray(expressions: IReadOnlyList<SqlExpression>, type_: Type, typeMapping?: RelationalTypeMapping): PgNewArrayExpression;
    newArrayOrConstant(elements: IReadOnlyList<SqlExpression>, type_: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    overlaps(left: SqlExpression, right: SqlExpression): SqlExpression;
    regexMatch(match: SqlExpression, pattern: SqlExpression, options: RegexOptions): PgRegexMatchExpression;
}


export const NpgsqlSqlExpressionFactory: {
    new(dependencies: SqlExpressionFactoryDependencies): NpgsqlSqlExpressionFactory;
};


export type NpgsqlSqlExpressionFactory = NpgsqlSqlExpressionFactory$instance;

