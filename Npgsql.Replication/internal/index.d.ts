// Generated by tsbindgen - Architecture
// Namespace: Npgsql.Replication
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { PgOutputReplicationMessage } from "../../Npgsql.Replication.PgOutput.Messages/internal/index.js";
import type { PgOutputReplicationOptions, PgOutputReplicationSlot } from "../../Npgsql.Replication.PgOutput/internal/index.js";
import type { TestDecodingData, TestDecodingOptions, TestDecodingReplicationSlot } from "../../Npgsql.Replication.TestDecoding/internal/index.js";
import type { NpgsqlLogSequenceNumber } from "../../NpgsqlTypes/internal/index.js";
import type { IAsyncEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTime, Enum, IAsyncDisposable, IComparable, IConvertible, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, UInt32, ValueType, Version, Void } from "@tsonic/dotnet/System.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum LogicalSlotSnapshotInitMode {
    export = 0,
    use = 1,
    noExport = 2
}


export interface ReplicationSlotOptions$instance {
    readonly consistentPoint: NpgsqlLogSequenceNumber;
    readonly slotName: string;
}


export const ReplicationSlotOptions: {
    new(slotName: string, consistentPoint: string): ReplicationSlotOptions;
    new(slotName: string, consistentPoint: NpgsqlLogSequenceNumber): ReplicationSlotOptions;
};


export type ReplicationSlotOptions = ReplicationSlotOptions$instance;

export interface TimelineHistoryFile$instance {
    readonly content: byte[];
    readonly fileName: string;
}


export const TimelineHistoryFile: {
    new(): TimelineHistoryFile;
};


export type TimelineHistoryFile = TimelineHistoryFile$instance;

export interface LogicalReplicationConnection$instance extends ReplicationConnection {
}


export const LogicalReplicationConnection: {
    new(): LogicalReplicationConnection;
    new(connectionString: string): LogicalReplicationConnection;
};


export type LogicalReplicationConnection = LogicalReplicationConnection$instance;

export interface PhysicalReplicationConnection$instance extends ReplicationConnection {
    createReplicationSlot(slotName: string, isTemporary?: boolean, reserveWal?: boolean, cancellationToken?: CancellationToken): Task<PhysicalReplicationSlot>;
    readReplicationSlot(slotName: string, cancellationToken?: CancellationToken): Task<PhysicalReplicationSlot | undefined>;
    startReplication(slot: PhysicalReplicationSlot, walLocation: NpgsqlLogSequenceNumber, cancellationToken: CancellationToken, timeline?: uint): IAsyncEnumerable<XLogDataMessage>;
    startReplication(walLocation: NpgsqlLogSequenceNumber, cancellationToken: CancellationToken, timeline?: uint): IAsyncEnumerable<XLogDataMessage>;
    startReplication(slot: PhysicalReplicationSlot, cancellationToken: CancellationToken): IAsyncEnumerable<XLogDataMessage>;
}


export const PhysicalReplicationConnection: {
    new(): PhysicalReplicationConnection;
    new(connectionString: string): PhysicalReplicationConnection;
};


export type PhysicalReplicationConnection = PhysicalReplicationConnection$instance;

export interface PhysicalReplicationSlot$instance extends ReplicationSlot {
    readonly restartLsn: Nullable<NpgsqlLogSequenceNumber>;
    readonly restartTimeline: Nullable<System_Internal.UInt32>;
}


export const PhysicalReplicationSlot: {
    new(slotName: string, restartLsn: Nullable<NpgsqlLogSequenceNumber>, restartTimeline: Nullable<System_Internal.UInt32>): PhysicalReplicationSlot;
};


export type PhysicalReplicationSlot = PhysicalReplicationSlot$instance;

export interface ReplicationConnection$instance {
    commandTimeout: TimeSpan;
    connectionString: string;
    readonly encoding: Encoding;
    lastAppliedLsn: NpgsqlLogSequenceNumber;
    lastFlushedLsn: NpgsqlLogSequenceNumber;
    readonly lastReceivedLsn: NpgsqlLogSequenceNumber;
    readonly postgreSqlVersion: Version;
    readonly processID: int;
    readonly serverVersion: string;
    walReceiverStatusInterval: TimeSpan;
    walReceiverTimeout: TimeSpan;
    disposeAsync(): ValueTask;
    dropReplicationSlot(slotName: string, wait?: boolean, cancellationToken?: CancellationToken): Task;
    identifySystem(cancellationToken?: CancellationToken): Task<ReplicationSystemIdentification>;
    open(cancellationToken?: CancellationToken): Task;
    sendStatusUpdate(cancellationToken?: CancellationToken): Task;
    setReplicationStatus(lastAppliedAndFlushedLsn: NpgsqlLogSequenceNumber): void;
    show(parameterName: string, cancellationToken?: CancellationToken): Task<System_Internal.String>;
    timelineHistory(tli: uint, cancellationToken?: CancellationToken): Task<TimelineHistoryFile>;
}


export const ReplicationConnection: {
};


export type ReplicationConnection = ReplicationConnection$instance;

export interface ReplicationMessage$instance {
    readonly serverClock: DateTime;
    readonly walEnd: NpgsqlLogSequenceNumber;
    readonly walStart: NpgsqlLogSequenceNumber;
}


export const ReplicationMessage: {
};


export type ReplicationMessage = ReplicationMessage$instance;

export interface ReplicationSlot$instance {
    readonly name: string;
}


export const ReplicationSlot: {
};


export type ReplicationSlot = ReplicationSlot$instance;

export interface ReplicationSystemIdentification$instance {
    readonly dbName: string | undefined;
    readonly systemId: string;
    readonly timeline: uint;
    readonly xLogPos: NpgsqlLogSequenceNumber;
}


export const ReplicationSystemIdentification: {
    new(): ReplicationSystemIdentification;
};


export type ReplicationSystemIdentification = ReplicationSystemIdentification$instance;

export interface XLogDataMessage$instance extends ReplicationMessage {
    readonly data: Stream;
}


export const XLogDataMessage: {
    new(): XLogDataMessage;
};


export type XLogDataMessage = XLogDataMessage$instance;

export abstract class PgOutputConnectionExtensions$instance {
    static createPgOutputReplicationSlot(connection: LogicalReplicationConnection, slotName: string, temporarySlot?: boolean, slotSnapshotInitMode?: Nullable<LogicalSlotSnapshotInitMode>, twoPhase?: boolean, cancellationToken?: CancellationToken): Task<PgOutputReplicationSlot>;
    static startReplication(connection: LogicalReplicationConnection, slot: PgOutputReplicationSlot, options: PgOutputReplicationOptions, cancellationToken: CancellationToken, walLocation?: Nullable<NpgsqlLogSequenceNumber>): IAsyncEnumerable<PgOutputReplicationMessage>;
}


export type PgOutputConnectionExtensions = PgOutputConnectionExtensions$instance;

export abstract class TestDecodingConnectionExtensions$instance {
    static createTestDecodingReplicationSlot(connection: LogicalReplicationConnection, slotName: string, temporarySlot?: boolean, slotSnapshotInitMode?: Nullable<LogicalSlotSnapshotInitMode>, twoPhase?: boolean, cancellationToken?: CancellationToken): Task<TestDecodingReplicationSlot>;
    static startReplication(connection: LogicalReplicationConnection, slot: TestDecodingReplicationSlot, cancellationToken: CancellationToken, options?: TestDecodingOptions, walLocation?: Nullable<NpgsqlLogSequenceNumber>): IAsyncEnumerable<TestDecodingData>;
}


export type TestDecodingConnectionExtensions = TestDecodingConnectionExtensions$instance;

