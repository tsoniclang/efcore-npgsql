// Generated by tsbindgen - Architecture
// Namespace: Npgsql.Replication
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { PgOutputReplicationMessage } from "../../Npgsql.Replication.PgOutput.Messages/internal/index.js";
import type { PgOutputReplicationOptions, PgOutputReplicationSlot } from "../../Npgsql.Replication.PgOutput/internal/index.js";
import type { TestDecodingData, TestDecodingOptions, TestDecodingReplicationSlot } from "../../Npgsql.Replication.TestDecoding/internal/index.js";
import type { NpgsqlLogSequenceNumber } from "../../NpgsqlTypes/internal/index.js";
import type { IAsyncEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTime, Enum, IAsyncDisposable, IComparable, IConvertible, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, UInt32, ValueType, Version, Void } from "@tsonic/dotnet/System.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum LogicalSlotSnapshotInitMode {
    Export = 0,
    Use = 1,
    NoExport = 2
}


export interface ReplicationSlotOptions$instance {
    readonly ConsistentPoint: NpgsqlLogSequenceNumber;
    readonly SlotName: string;
}


export const ReplicationSlotOptions: {
    new(slotName: string, consistentPoint: string): ReplicationSlotOptions;
    new(slotName: string, consistentPoint: NpgsqlLogSequenceNumber): ReplicationSlotOptions;
};


export type ReplicationSlotOptions = ReplicationSlotOptions$instance;

export interface TimelineHistoryFile$instance {
    readonly Content: byte[];
    readonly FileName: string;
}


export const TimelineHistoryFile: {
    new(): TimelineHistoryFile;
};


export type TimelineHistoryFile = TimelineHistoryFile$instance;

export interface LogicalReplicationConnection$instance extends ReplicationConnection {
}


export const LogicalReplicationConnection: {
    new(): LogicalReplicationConnection;
    new(connectionString: string): LogicalReplicationConnection;
};


export type LogicalReplicationConnection = LogicalReplicationConnection$instance;

export interface PhysicalReplicationConnection$instance extends ReplicationConnection {
    CreateReplicationSlot(slotName: string, isTemporary?: boolean, reserveWal?: boolean, cancellationToken?: CancellationToken): Task<PhysicalReplicationSlot>;
    ReadReplicationSlot(slotName: string, cancellationToken?: CancellationToken): Task<PhysicalReplicationSlot | undefined>;
    StartReplication(slot: PhysicalReplicationSlot, walLocation: NpgsqlLogSequenceNumber, cancellationToken: CancellationToken, timeline?: uint): IAsyncEnumerable<XLogDataMessage>;
    StartReplication(walLocation: NpgsqlLogSequenceNumber, cancellationToken: CancellationToken, timeline?: uint): IAsyncEnumerable<XLogDataMessage>;
    StartReplication(slot: PhysicalReplicationSlot, cancellationToken: CancellationToken): IAsyncEnumerable<XLogDataMessage>;
}


export const PhysicalReplicationConnection: {
    new(): PhysicalReplicationConnection;
    new(connectionString: string): PhysicalReplicationConnection;
};


export type PhysicalReplicationConnection = PhysicalReplicationConnection$instance;

export interface PhysicalReplicationSlot$instance extends ReplicationSlot {
    readonly RestartLsn: Nullable<NpgsqlLogSequenceNumber>;
    readonly RestartTimeline: Nullable<System_Internal.UInt32>;
}


export const PhysicalReplicationSlot: {
    new(slotName: string, restartLsn: Nullable<NpgsqlLogSequenceNumber>, restartTimeline: Nullable<System_Internal.UInt32>): PhysicalReplicationSlot;
};


export type PhysicalReplicationSlot = PhysicalReplicationSlot$instance;

export interface ReplicationConnection$instance {
    CommandTimeout: TimeSpan;
    ConnectionString: string;
    readonly Encoding: Encoding;
    LastAppliedLsn: NpgsqlLogSequenceNumber;
    LastFlushedLsn: NpgsqlLogSequenceNumber;
    readonly LastReceivedLsn: NpgsqlLogSequenceNumber;
    readonly PostgreSqlVersion: Version;
    readonly ProcessID: int;
    readonly ServerVersion: string;
    WalReceiverStatusInterval: TimeSpan;
    WalReceiverTimeout: TimeSpan;
    DisposeAsync(): ValueTask;
    DropReplicationSlot(slotName: string, wait?: boolean, cancellationToken?: CancellationToken): Task;
    IdentifySystem(cancellationToken?: CancellationToken): Task<ReplicationSystemIdentification>;
    Open(cancellationToken?: CancellationToken): Task;
    SendStatusUpdate(cancellationToken?: CancellationToken): Task;
    SetReplicationStatus(lastAppliedAndFlushedLsn: NpgsqlLogSequenceNumber): void;
    Show(parameterName: string, cancellationToken?: CancellationToken): Task<System_Internal.String>;
    TimelineHistory(tli: uint, cancellationToken?: CancellationToken): Task<TimelineHistoryFile>;
}


export const ReplicationConnection: {
};


export type ReplicationConnection = ReplicationConnection$instance;

export interface ReplicationMessage$instance {
    readonly ServerClock: DateTime;
    readonly WalEnd: NpgsqlLogSequenceNumber;
    readonly WalStart: NpgsqlLogSequenceNumber;
}


export const ReplicationMessage: {
};


export type ReplicationMessage = ReplicationMessage$instance;

export interface ReplicationSlot$instance {
    readonly Name: string;
}


export const ReplicationSlot: {
};


export type ReplicationSlot = ReplicationSlot$instance;

export interface ReplicationSystemIdentification$instance {
    readonly DbName: string | undefined;
    readonly SystemId: string;
    readonly Timeline: uint;
    readonly XLogPos: NpgsqlLogSequenceNumber;
}


export const ReplicationSystemIdentification: {
    new(): ReplicationSystemIdentification;
};


export type ReplicationSystemIdentification = ReplicationSystemIdentification$instance;

export interface XLogDataMessage$instance extends ReplicationMessage {
    readonly Data: Stream;
}


export const XLogDataMessage: {
    new(): XLogDataMessage;
};


export type XLogDataMessage = XLogDataMessage$instance;

export abstract class PgOutputConnectionExtensions$instance {
    static CreatePgOutputReplicationSlot(connection: LogicalReplicationConnection, slotName: string, temporarySlot?: boolean, slotSnapshotInitMode?: Nullable<LogicalSlotSnapshotInitMode>, twoPhase?: boolean, cancellationToken?: CancellationToken): Task<PgOutputReplicationSlot>;
    static StartReplication(connection: LogicalReplicationConnection, slot: PgOutputReplicationSlot, options: PgOutputReplicationOptions, cancellationToken: CancellationToken, walLocation?: Nullable<NpgsqlLogSequenceNumber>): IAsyncEnumerable<PgOutputReplicationMessage>;
}


export type PgOutputConnectionExtensions = PgOutputConnectionExtensions$instance;

export abstract class TestDecodingConnectionExtensions$instance {
    static CreateTestDecodingReplicationSlot(connection: LogicalReplicationConnection, slotName: string, temporarySlot?: boolean, slotSnapshotInitMode?: Nullable<LogicalSlotSnapshotInitMode>, twoPhase?: boolean, cancellationToken?: CancellationToken): Task<TestDecodingReplicationSlot>;
    static StartReplication(connection: LogicalReplicationConnection, slot: TestDecodingReplicationSlot, cancellationToken: CancellationToken, options?: TestDecodingOptions, walLocation?: Nullable<NpgsqlLogSequenceNumber>): IAsyncEnumerable<TestDecodingData>;
}


export type TestDecodingConnectionExtensions = TestDecodingConnectionExtensions$instance;

