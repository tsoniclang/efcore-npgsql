// Generated by tsbindgen - Architecture
// Namespace: Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions.Internal
// Assembly: Npgsql.EntityFrameworkCore.PostgreSQL

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { PgExpressionType } from "../../Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions/internal/index.js";
import type { IEnumerable, IReadOnlyList, ISet } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Enum, IComparable, IConvertible, IEquatable, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Linq_Expressions_Internal from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { Expression, ExpressionType, ExpressionVisitor } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { RegexOptions } from "@tsonic/dotnet/System.Text.RegularExpressions.js";
import * as Microsoft_EntityFrameworkCore_Query_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import type { ExpressionPrinter, IPrintableExpression, IRelationalQuotableExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import * as Microsoft_EntityFrameworkCore_Query_SqlExpressions_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { ITableBasedExpression, OrderingExpression, SqlExpression, SqlFunctionExpression, TableExpression, TableExpressionBase, TableValuedFunctionExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { RelationalTypeMapping } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Storage.js";

export enum PgAllOperatorType {
    like = 0,
    iLike = 1
}


export enum PgAnyOperatorType {
    equal = 0,
    like = 1,
    iLike = 2
}


export interface PgTableValuedFunctionExpression_ColumnInfo$instance {
    name: string;
    get typeMapping(): RelationalTypeMapping | undefined;
    set typeMapping(value: RelationalTypeMapping);
    deconstruct(Name: string, TypeMapping: RelationalTypeMapping): void;
    equals(obj: unknown): boolean;
    equals(other: PgTableValuedFunctionExpression_ColumnInfo): boolean;
    getHashCode(): int;
    toString(): string;
}


export const PgTableValuedFunctionExpression_ColumnInfo: {
    new(Name: string, TypeMapping: RelationalTypeMapping): PgTableValuedFunctionExpression_ColumnInfo;
};


export type PgTableValuedFunctionExpression_ColumnInfo = PgTableValuedFunctionExpression_ColumnInfo$instance;

export interface PgAllExpression$instance extends SqlExpression {
    readonly array: SqlExpression;
    readonly item: SqlExpression;
    readonly operatorType: PgAllOperatorType;
    readonly type_: Type;
    equals(obj: unknown): boolean;
    equals(other: PgAllExpression): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(item: SqlExpression, array: SqlExpression): PgAllExpression;
}


export const PgAllExpression: {
    new(item: SqlExpression, array: SqlExpression, operatorType: PgAllOperatorType, typeMapping: RelationalTypeMapping): PgAllExpression;
};


export type PgAllExpression = PgAllExpression$instance;

export interface PgAnyExpression$instance extends SqlExpression {
    readonly array: SqlExpression;
    readonly item: SqlExpression;
    readonly operatorType: PgAnyOperatorType;
    readonly type_: Type;
    equals(obj: unknown): boolean;
    equals(other: PgAnyExpression): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(item: SqlExpression, array: SqlExpression): PgAnyExpression;
}


export const PgAnyExpression: {
    new(item: SqlExpression, array: SqlExpression, operatorType: PgAnyOperatorType, typeMapping: RelationalTypeMapping): PgAnyExpression;
};


export type PgAnyExpression = PgAnyExpression$instance;

export interface PgArrayIndexExpression$instance extends SqlExpression {
    readonly array: SqlExpression;
    readonly index: SqlExpression;
    readonly isNullable: boolean;
    equals(other: PgArrayIndexExpression): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(array: SqlExpression, index: SqlExpression): PgArrayIndexExpression;
}


export const PgArrayIndexExpression: {
    new(array: SqlExpression, index: SqlExpression, nullable: boolean, type_: Type, typeMapping: RelationalTypeMapping): PgArrayIndexExpression;
};


export type PgArrayIndexExpression = PgArrayIndexExpression$instance;

export interface PgArraySliceExpression$instance extends SqlExpression {
    readonly array: SqlExpression;
    readonly isNullable: boolean;
    readonly lowerBound: SqlExpression;
    readonly upperBound: SqlExpression;
    equals(other: PgArraySliceExpression): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(array: SqlExpression, lowerBound: SqlExpression, upperBound: SqlExpression): PgArraySliceExpression;
}


export const PgArraySliceExpression: {
    new(array: SqlExpression, lowerBound: SqlExpression, upperBound: SqlExpression, nullable: boolean, type_: Type, typeMapping: RelationalTypeMapping): PgArraySliceExpression;
};


export type PgArraySliceExpression = PgArraySliceExpression$instance;

export interface PgBinaryExpression$instance extends SqlExpression {
    readonly left: SqlExpression;
    readonly operatorType: PgExpressionType;
    readonly right: SqlExpression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    update(left: SqlExpression, right: SqlExpression): PgBinaryExpression;
}


export const PgBinaryExpression: {
    new(operatorType: PgExpressionType, left: SqlExpression, right: SqlExpression, type_: Type, typeMapping: RelationalTypeMapping): PgBinaryExpression;
};


export type PgBinaryExpression = PgBinaryExpression$instance;

export interface PgDeleteExpression$instance extends Expression {
    readonly fromItems: IReadOnlyList<TableExpressionBase>;
    readonly nodeType: ExpressionType;
    readonly predicate: SqlExpression | undefined;
    readonly table: TableExpression;
    readonly tags: ISet<System_Internal.String>;
    readonly type_: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    print(expressionPrinter: ExpressionPrinter): void;
    update(predicate: SqlExpression): PgDeleteExpression;
}


export const PgDeleteExpression: {
    new(table: TableExpression, fromItems: IReadOnlyList<TableExpressionBase>, predicate: SqlExpression, tags: ISet<System_Internal.String>): PgDeleteExpression;
};


export type PgDeleteExpression = PgDeleteExpression$instance;

export interface PgFunctionExpression$instance extends SqlFunctionExpression {
    readonly aggregateOrderings: IReadOnlyList<OrderingExpression>;
    readonly aggregatePredicate: SqlExpression | undefined;
    readonly argumentNames: IReadOnlyList<string | undefined>;
    readonly arguments: IReadOnlyList<SqlExpression>;
    readonly argumentSeparators: IReadOnlyList<string | undefined>;
    readonly argumentsPropagateNullability: IReadOnlyList<System_Internal.Boolean>;
    readonly isAggregateDistinct: boolean;
    applyTypeMapping(typeMapping: RelationalTypeMapping): SqlFunctionExpression;
    equals(obj: unknown): boolean;
    equals(other: PgFunctionExpression): boolean;
    getHashCode(): int;
    update(instance: SqlExpression, arguments: IReadOnlyList<SqlExpression>): SqlFunctionExpression;
    updateAggregateComponents(predicate: SqlExpression, orderings: IReadOnlyList<OrderingExpression>): PgFunctionExpression;
}


export const PgFunctionExpression: {
    new(name: string, arguments: IEnumerable<SqlExpression>, argumentNames: IEnumerable<System_Internal.String>, argumentSeparators: IEnumerable<System_Internal.String>, aggregateDistinct: boolean, aggregatePredicate: SqlExpression, aggregateOrderings: IReadOnlyList<OrderingExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, type_: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
    createWithArgumentSeparators(name: string, arguments: IEnumerable<SqlExpression>, argumentSeparators: IEnumerable<System_Internal.String>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, builtIn: boolean, type_: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
    createWithNamedArguments(name: string, arguments: IEnumerable<SqlExpression>, argumentNames: IEnumerable<System_Internal.String>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, builtIn: boolean, type_: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
};


export type PgFunctionExpression = PgFunctionExpression$instance;

export interface PgILikeExpression$instance extends SqlExpression {
    readonly escapeChar: SqlExpression | undefined;
    readonly match: SqlExpression;
    readonly pattern: SqlExpression;
    equals(obj: unknown): boolean;
    equals(other: PgILikeExpression): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(match: SqlExpression, pattern: SqlExpression, escapeChar: SqlExpression): PgILikeExpression;
}


export const PgILikeExpression: {
    new(match: SqlExpression, pattern: SqlExpression, escapeChar: SqlExpression, typeMapping: RelationalTypeMapping): PgILikeExpression;
};


export type PgILikeExpression = PgILikeExpression$instance;

export interface PgJsonTraversalExpression$instance extends SqlExpression {
    readonly expression: SqlExpression;
    readonly path: IReadOnlyList<SqlExpression>;
    readonly returnsText: boolean;
    append(pathComponent: SqlExpression): PgJsonTraversalExpression;
    equals(obj: unknown): boolean;
    equals(other: PgJsonTraversalExpression): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(expression: SqlExpression, path: IReadOnlyList<SqlExpression>): PgJsonTraversalExpression;
}


export const PgJsonTraversalExpression: {
    new(expression: SqlExpression, path: IReadOnlyList<SqlExpression>, returnsText: boolean, type_: Type, typeMapping: RelationalTypeMapping): PgJsonTraversalExpression;
};


export type PgJsonTraversalExpression = PgJsonTraversalExpression$instance;

export interface PgNewArrayExpression$instance extends SqlExpression {
    readonly expressions: IReadOnlyList<SqlExpression>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    update(expressions: IReadOnlyList<SqlExpression>): PgNewArrayExpression;
}


export const PgNewArrayExpression: {
    new(expressions: IReadOnlyList<SqlExpression>, type_: Type, typeMapping: RelationalTypeMapping): PgNewArrayExpression;
};


export type PgNewArrayExpression = PgNewArrayExpression$instance;

export interface PgRegexMatchExpression$instance extends SqlExpression {
    readonly match: SqlExpression;
    readonly options: RegexOptions;
    readonly pattern: SqlExpression;
    readonly type_: Type;
    equals(other: PgRegexMatchExpression): boolean;
    equals(other: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(match: SqlExpression, pattern: SqlExpression): PgRegexMatchExpression;
}


export const PgRegexMatchExpression: {
    new(match: SqlExpression, pattern: SqlExpression, options: RegexOptions, typeMapping: RelationalTypeMapping): PgRegexMatchExpression;
};


export type PgRegexMatchExpression = PgRegexMatchExpression$instance;

export interface PgRowValueExpression$instance extends SqlExpression {
    readonly values: IReadOnlyList<SqlExpression>;
    equals(obj: unknown): boolean;
    equals(other: PgRowValueExpression): boolean;
    getHashCode(): int;
    quote(): Expression;
    update(values: IReadOnlyList<SqlExpression>): PgRowValueExpression;
}


export const PgRowValueExpression: {
    new(values: IReadOnlyList<SqlExpression>, type_: Type, typeMapping: RelationalTypeMapping): PgRowValueExpression;
};


export type PgRowValueExpression = PgRowValueExpression$instance;

export interface PgTableValuedFunctionExpression$instance extends TableValuedFunctionExpression {
    readonly columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo> | undefined;
    readonly withOrdinality: boolean;
    clone(alias: string, cloningExpressionVisitor: ExpressionVisitor): TableExpressionBase;
    equals(obj: unknown): boolean;
    equals(expression: PgTableValuedFunctionExpression): boolean;
    getHashCode(): int;
    update(arguments: IReadOnlyList<SqlExpression>): PgTableValuedFunctionExpression;
    withAlias(newAlias: string): PgTableValuedFunctionExpression;
    withColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgTableValuedFunctionExpression;
}


export const PgTableValuedFunctionExpression: {
    new(alias: string, name: string, arguments: IReadOnlyList<SqlExpression>, columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>, withOrdinality: boolean): PgTableValuedFunctionExpression;
};


export type PgTableValuedFunctionExpression = PgTableValuedFunctionExpression$instance;

export interface PgUnknownBinaryExpression$instance extends SqlExpression {
    readonly left: SqlExpression;
    readonly operator: string;
    readonly right: SqlExpression;
    equals(other: PgUnknownBinaryExpression): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
    update(left: SqlExpression, right: SqlExpression): PgUnknownBinaryExpression;
}


export const PgUnknownBinaryExpression: {
    new(left: SqlExpression, right: SqlExpression, binaryOperator: string, type_: Type, typeMapping: RelationalTypeMapping): PgUnknownBinaryExpression;
};


export type PgUnknownBinaryExpression = PgUnknownBinaryExpression$instance;

export interface PgUnnestExpression$instance extends PgTableValuedFunctionExpression {
    readonly array: SqlExpression;
    readonly columnName: string;
    clone(alias: string, cloningExpressionVisitor: ExpressionVisitor): TableExpressionBase;
    update(arguments: IReadOnlyList<SqlExpression>): PgUnnestExpression;
    update(array: SqlExpression): PgUnnestExpression;
    update(arguments: IReadOnlyList<SqlExpression>): PgTableValuedFunctionExpression;
    withAlias(newAlias: string): PgUnnestExpression;
    withAlias(newAlias: string): PgTableValuedFunctionExpression;
    withColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgUnnestExpression;
    withColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgTableValuedFunctionExpression;
}


export const PgUnnestExpression: {
    new(alias: string, array: SqlExpression, columnName: string, withOrdinality: boolean): PgUnnestExpression;
};


export type PgUnnestExpression = PgUnnestExpression$instance;

