// Generated by tsbindgen - Architecture
// Namespace: Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions.Internal
// Assembly: Npgsql.EntityFrameworkCore.PostgreSQL

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { PgExpressionType } from "../../Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions/internal/index.js";
import type { IEnumerable, IReadOnlyList, ISet } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Enum, IComparable, IConvertible, IEquatable, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Linq_Expressions_Internal from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { Expression, ExpressionType, ExpressionVisitor } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { RegexOptions } from "@tsonic/dotnet/System.Text.RegularExpressions.js";
import * as Microsoft_EntityFrameworkCore_Query_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import type { ExpressionPrinter, IPrintableExpression, IRelationalQuotableExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import * as Microsoft_EntityFrameworkCore_Query_SqlExpressions_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { ITableBasedExpression, OrderingExpression, SqlExpression, SqlFunctionExpression, TableExpression, TableExpressionBase, TableValuedFunctionExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { RelationalTypeMapping } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Storage.js";

export enum PgAllOperatorType {
    Like = 0,
    ILike = 1
}


export enum PgAnyOperatorType {
    Equal = 0,
    Like = 1,
    ILike = 2
}


export interface PgTableValuedFunctionExpression_ColumnInfo$instance {
    Name: string;
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping);
    Deconstruct(Name: string, TypeMapping: RelationalTypeMapping): void;
    Equals(obj: unknown): boolean;
    Equals(other: PgTableValuedFunctionExpression_ColumnInfo): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const PgTableValuedFunctionExpression_ColumnInfo: {
    new(Name: string, TypeMapping: RelationalTypeMapping): PgTableValuedFunctionExpression_ColumnInfo;
};


export type PgTableValuedFunctionExpression_ColumnInfo = PgTableValuedFunctionExpression_ColumnInfo$instance;

export abstract class PgAllExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgAllExpression$instance extends PgAllExpression$protected, SqlExpression {
    readonly Array: SqlExpression;
    readonly Item: SqlExpression;
    readonly OperatorType: PgAllOperatorType;
    readonly Type: Type;
    Equals(obj: unknown): boolean;
    Equals(other: PgAllExpression): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(item: SqlExpression, array: SqlExpression): PgAllExpression;
}


export const PgAllExpression: {
    new(item: SqlExpression, array: SqlExpression, operatorType: PgAllOperatorType, typeMapping: RelationalTypeMapping): PgAllExpression;
};


export type PgAllExpression = PgAllExpression$instance;

export abstract class PgAnyExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgAnyExpression$instance extends PgAnyExpression$protected, SqlExpression {
    readonly Array: SqlExpression;
    readonly Item: SqlExpression;
    readonly OperatorType: PgAnyOperatorType;
    readonly Type: Type;
    Equals(obj: unknown): boolean;
    Equals(other: PgAnyExpression): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(item: SqlExpression, array: SqlExpression): PgAnyExpression;
}


export const PgAnyExpression: {
    new(item: SqlExpression, array: SqlExpression, operatorType: PgAnyOperatorType, typeMapping: RelationalTypeMapping): PgAnyExpression;
};


export type PgAnyExpression = PgAnyExpression$instance;

export abstract class PgArrayIndexExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgArrayIndexExpression$instance extends PgArrayIndexExpression$protected, SqlExpression {
    readonly Array: SqlExpression;
    readonly Index: SqlExpression;
    readonly IsNullable: boolean;
    Equals(other: PgArrayIndexExpression): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(array: SqlExpression, index: SqlExpression): PgArrayIndexExpression;
}


export const PgArrayIndexExpression: {
    new(array: SqlExpression, index: SqlExpression, nullable: boolean, type: Type, typeMapping: RelationalTypeMapping): PgArrayIndexExpression;
};


export type PgArrayIndexExpression = PgArrayIndexExpression$instance;

export abstract class PgArraySliceExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgArraySliceExpression$instance extends PgArraySliceExpression$protected, SqlExpression {
    readonly Array: SqlExpression;
    readonly IsNullable: boolean;
    readonly LowerBound: SqlExpression;
    readonly UpperBound: SqlExpression;
    Equals(other: PgArraySliceExpression): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(array: SqlExpression, lowerBound: SqlExpression, upperBound: SqlExpression): PgArraySliceExpression;
}


export const PgArraySliceExpression: {
    new(array: SqlExpression, lowerBound: SqlExpression, upperBound: SqlExpression, nullable: boolean, type: Type, typeMapping: RelationalTypeMapping): PgArraySliceExpression;
};


export type PgArraySliceExpression = PgArraySliceExpression$instance;

export abstract class PgBinaryExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgBinaryExpression$instance extends PgBinaryExpression$protected, SqlExpression {
    readonly Left: SqlExpression;
    readonly OperatorType: PgExpressionType;
    readonly Right: SqlExpression;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    Update(left: SqlExpression, right: SqlExpression): PgBinaryExpression;
}


export const PgBinaryExpression: {
    new(operatorType: PgExpressionType, left: SqlExpression, right: SqlExpression, type: Type, typeMapping: RelationalTypeMapping): PgBinaryExpression;
};


export type PgBinaryExpression = PgBinaryExpression$instance;

export abstract class PgDeleteExpression$protected {
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgDeleteExpression$instance extends PgDeleteExpression$protected, Expression {
    readonly FromItems: IReadOnlyList<TableExpressionBase>;
    readonly NodeType: ExpressionType;
    readonly Predicate: SqlExpression | undefined;
    readonly Table: TableExpression;
    readonly Tags: ISet<System_Internal.String>;
    readonly Type: Type;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(predicate: SqlExpression): PgDeleteExpression;
}


export const PgDeleteExpression: {
    new(table: TableExpression, fromItems: IReadOnlyList<TableExpressionBase>, predicate: SqlExpression, tags: ISet<System_Internal.String>): PgDeleteExpression;
};


export type PgDeleteExpression = PgDeleteExpression$instance;

export abstract class PgFunctionExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgFunctionExpression$instance extends PgFunctionExpression$protected, SqlFunctionExpression {
    readonly AggregateOrderings: IReadOnlyList<OrderingExpression>;
    readonly AggregatePredicate: SqlExpression | undefined;
    readonly ArgumentNames: IReadOnlyList<string | undefined>;
    readonly Arguments: IReadOnlyList<SqlExpression>;
    readonly ArgumentSeparators: IReadOnlyList<string | undefined>;
    readonly ArgumentsPropagateNullability: IReadOnlyList<System_Internal.Boolean>;
    readonly IsAggregateDistinct: boolean;
    ApplyTypeMapping(typeMapping: RelationalTypeMapping): SqlFunctionExpression;
    Equals(obj: unknown): boolean;
    Equals(other: PgFunctionExpression): boolean;
    GetHashCode(): int;
    Update(instance: SqlExpression, arguments: IReadOnlyList<SqlExpression>): SqlFunctionExpression;
    UpdateAggregateComponents(predicate: SqlExpression, orderings: IReadOnlyList<OrderingExpression>): PgFunctionExpression;
}


export const PgFunctionExpression: {
    new(name: string, arguments: IEnumerable<SqlExpression>, argumentNames: IEnumerable<System_Internal.String>, argumentSeparators: IEnumerable<System_Internal.String>, aggregateDistinct: boolean, aggregatePredicate: SqlExpression, aggregateOrderings: IReadOnlyList<OrderingExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, type: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
    CreateWithArgumentSeparators(name: string, arguments: IEnumerable<SqlExpression>, argumentSeparators: IEnumerable<System_Internal.String>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, builtIn: boolean, type: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
    CreateWithNamedArguments(name: string, arguments: IEnumerable<SqlExpression>, argumentNames: IEnumerable<System_Internal.String>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, builtIn: boolean, type: Type, typeMapping: RelationalTypeMapping): PgFunctionExpression;
};


export type PgFunctionExpression = PgFunctionExpression$instance;

export abstract class PgILikeExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgILikeExpression$instance extends PgILikeExpression$protected, SqlExpression {
    readonly EscapeChar: SqlExpression | undefined;
    readonly Match: SqlExpression;
    readonly Pattern: SqlExpression;
    Equals(obj: unknown): boolean;
    Equals(other: PgILikeExpression): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(match: SqlExpression, pattern: SqlExpression, escapeChar: SqlExpression): PgILikeExpression;
}


export const PgILikeExpression: {
    new(match: SqlExpression, pattern: SqlExpression, escapeChar: SqlExpression, typeMapping: RelationalTypeMapping): PgILikeExpression;
};


export type PgILikeExpression = PgILikeExpression$instance;

export abstract class PgJsonTraversalExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgJsonTraversalExpression$instance extends PgJsonTraversalExpression$protected, SqlExpression {
    readonly Expression: SqlExpression;
    readonly Path: IReadOnlyList<SqlExpression>;
    readonly ReturnsText: boolean;
    Append(pathComponent: SqlExpression): PgJsonTraversalExpression;
    Equals(obj: unknown): boolean;
    Equals(other: PgJsonTraversalExpression): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(expression: SqlExpression, path: IReadOnlyList<SqlExpression>): PgJsonTraversalExpression;
}


export const PgJsonTraversalExpression: {
    new(expression: SqlExpression, path: IReadOnlyList<SqlExpression>, returnsText: boolean, type: Type, typeMapping: RelationalTypeMapping): PgJsonTraversalExpression;
};


export type PgJsonTraversalExpression = PgJsonTraversalExpression$instance;

export abstract class PgNewArrayExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgNewArrayExpression$instance extends PgNewArrayExpression$protected, SqlExpression {
    readonly Expressions: IReadOnlyList<SqlExpression>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    Update(expressions: IReadOnlyList<SqlExpression>): PgNewArrayExpression;
}


export const PgNewArrayExpression: {
    new(expressions: IReadOnlyList<SqlExpression>, type: Type, typeMapping: RelationalTypeMapping): PgNewArrayExpression;
};


export type PgNewArrayExpression = PgNewArrayExpression$instance;

export abstract class PgRegexMatchExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgRegexMatchExpression$instance extends PgRegexMatchExpression$protected, SqlExpression {
    readonly Match: SqlExpression;
    readonly Options: RegexOptions;
    readonly Pattern: SqlExpression;
    readonly Type: Type;
    Equals(other: PgRegexMatchExpression): boolean;
    Equals(other: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(match: SqlExpression, pattern: SqlExpression): PgRegexMatchExpression;
}


export const PgRegexMatchExpression: {
    new(match: SqlExpression, pattern: SqlExpression, options: RegexOptions, typeMapping: RelationalTypeMapping): PgRegexMatchExpression;
};


export type PgRegexMatchExpression = PgRegexMatchExpression$instance;

export abstract class PgRowValueExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgRowValueExpression$instance extends PgRowValueExpression$protected, SqlExpression {
    readonly Values: IReadOnlyList<SqlExpression>;
    Equals(obj: unknown): boolean;
    Equals(other: PgRowValueExpression): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    Update(values: IReadOnlyList<SqlExpression>): PgRowValueExpression;
}


export const PgRowValueExpression: {
    new(values: IReadOnlyList<SqlExpression>, type: Type, typeMapping: RelationalTypeMapping): PgRowValueExpression;
};


export type PgRowValueExpression = PgRowValueExpression$instance;

export abstract class PgTableValuedFunctionExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgTableValuedFunctionExpression$instance extends PgTableValuedFunctionExpression$protected, TableValuedFunctionExpression {
    readonly ColumnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo> | undefined;
    readonly WithOrdinality: boolean;
    Clone(alias: string, cloningExpressionVisitor: ExpressionVisitor): TableExpressionBase;
    Equals(obj: unknown): boolean;
    Equals(expression: PgTableValuedFunctionExpression): boolean;
    GetHashCode(): int;
    Update(arguments: IReadOnlyList<SqlExpression>): PgTableValuedFunctionExpression;
    WithAlias(newAlias: string): PgTableValuedFunctionExpression;
    WithColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgTableValuedFunctionExpression;
}


export const PgTableValuedFunctionExpression: {
    new(alias: string, name: string, arguments: IReadOnlyList<SqlExpression>, columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>, withOrdinality: boolean): PgTableValuedFunctionExpression;
};


export type PgTableValuedFunctionExpression = PgTableValuedFunctionExpression$instance;

export abstract class PgUnknownBinaryExpression$protected {
    protected Print(expressionPrinter: ExpressionPrinter): void;
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgUnknownBinaryExpression$instance extends PgUnknownBinaryExpression$protected, SqlExpression {
    readonly Left: SqlExpression;
    readonly Operator: string;
    readonly Right: SqlExpression;
    Equals(other: PgUnknownBinaryExpression): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
    Update(left: SqlExpression, right: SqlExpression): PgUnknownBinaryExpression;
}


export const PgUnknownBinaryExpression: {
    new(left: SqlExpression, right: SqlExpression, binaryOperator: string, type: Type, typeMapping: RelationalTypeMapping): PgUnknownBinaryExpression;
};


export type PgUnknownBinaryExpression = PgUnknownBinaryExpression$instance;

export abstract class PgUnnestExpression$protected {
    protected VisitChildren(visitor: ExpressionVisitor): Expression;
}


export interface PgUnnestExpression$instance extends PgUnnestExpression$protected, PgTableValuedFunctionExpression {
    readonly Array: SqlExpression;
    readonly ColumnName: string;
    Clone(alias: string, cloningExpressionVisitor: ExpressionVisitor): TableExpressionBase;
    Update(arguments: IReadOnlyList<SqlExpression>): PgUnnestExpression;
    Update(array: SqlExpression): PgUnnestExpression;
    Update(arguments: IReadOnlyList<SqlExpression>): PgTableValuedFunctionExpression;
    WithAlias(newAlias: string): PgUnnestExpression;
    WithAlias(newAlias: string): PgTableValuedFunctionExpression;
    WithColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgUnnestExpression;
    WithColumnInfos(columnInfos: IReadOnlyList<PgTableValuedFunctionExpression_ColumnInfo>): PgTableValuedFunctionExpression;
}


export const PgUnnestExpression: {
    new(alias: string, array: SqlExpression, columnName: string, withOrdinality: boolean): PgUnnestExpression;
};


export type PgUnnestExpression = PgUnnestExpression$instance;

