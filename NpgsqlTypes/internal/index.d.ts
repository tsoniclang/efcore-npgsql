// Generated by tsbindgen - Architecture
// Namespace: NpgsqlTypes
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ICollection, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, IList, IReadOnlyList, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { ITypeDescriptorContext, TypeConverter } from "@tsonic/dotnet/System.ComponentModel.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Char, Double, Enum, IComparable, IConvertible, IEquatable, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, ReadOnlySpan, String as ClrString, Type, UInt16, UInt32, UInt64, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { IPAddress } from "@tsonic/dotnet/System.Net.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";

export enum NpgsqlDbType {
    bigint = 1,
    double = 8,
    integer = 9,
    numeric = 13,
    real = 17,
    smallint = 18,
    money = 12,
    boolean = 2,
    box = 3,
    circle = 5,
    line = 10,
    lSeg = 11,
    path = 14,
    point = 15,
    polygon = 16,
    cube = 63,
    char = 6,
    text = 19,
    varchar = 22,
    name = 32,
    citext = 51,
    internalChar = 38,
    bytea = 4,
    date = 7,
    time = 20,
    timestamp = 21,
    timestampTz = 26,
    interval = 30,
    timeTz = 31,
    abstime = 33,
    inet = 24,
    cidr = 44,
    macAddr = 34,
    macAddr8 = 54,
    bit = 25,
    varbit = 39,
    tsVector = 45,
    tsQuery = 46,
    regconfig = 56,
    uuid = 27,
    xml = 28,
    json = 35,
    jsonb = 36,
    jsonPath = 57,
    hstore = 37,
    refcursor = 23,
    oidvector = 29,
    int2Vector = 52,
    oid = 41,
    xid = 42,
    xid8 = 64,
    cid = 43,
    regtype = 49,
    tid = 53,
    pgLsn = 59,
    unknown = 40,
    geometry = 50,
    geography = 55,
    lTree = 60,
    lQuery = 61,
    lTxtQuery = 62,
    integerRange = 1073741833,
    bigIntRange = 1073741825,
    numericRange = 1073741837,
    timestampRange = 1073741845,
    timestampTzRange = 1073741850,
    dateRange = 1073741831,
    integerMultirange = 536870921,
    bigIntMultirange = 536870913,
    numericMultirange = 536870925,
    timestampMultirange = 536870933,
    timestampTzMultirange = 536870938,
    dateMultirange = 536870919,
    array = -2147483648,
    range = 1073741824,
    multirange = 536870912
}


export enum NpgsqlTsQuery_NodeKind {
    empty = -1,
    lexeme = 0,
    not = 1,
    and = 2,
    or = 3,
    phrase = 4
}


export enum NpgsqlTsQueryLexeme_Weight {
    none = 0,
    D = 1,
    C = 2,
    B = 4,
    A = 8
}


export enum NpgsqlTsVector_Lexeme_Weight {
    D = 0,
    C = 1,
    B = 2,
    A = 3
}


export interface NpgsqlBox$instance {
    readonly bottom: double;
    readonly height: double;
    readonly isEmpty: boolean;
    readonly left: double;
    lowerLeft: NpgsqlPoint;
    readonly right: double;
    readonly top: double;
    upperRight: NpgsqlPoint;
    readonly width: double;
    deconstruct(lowerLeft: NpgsqlPoint, upperRight: NpgsqlPoint): void;
    deconstruct(left: double, right: double, bottom: double, top: double): void;
    deconstruct(left: double, right: double, bottom: double, top: double, width: double, height: double): void;
    equals(other: NpgsqlBox): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlBox: {
    new(upperRight: NpgsqlPoint, lowerLeft: NpgsqlPoint): NpgsqlBox;
    new(top: double, right: double, bottom: double, left: double): NpgsqlBox;
};


export type NpgsqlBox = NpgsqlBox$instance;

export interface NpgsqlCidr$instance {
    readonly address: IPAddress;
    readonly netmask: byte;
    deconstruct(address: IPAddress, netmask: byte): void;
    equals(obj: unknown): boolean;
    equals(other: NpgsqlCidr): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlCidr: {
    new(address: IPAddress, netmask: byte): NpgsqlCidr;
    new(addr: string): NpgsqlCidr;
};


export type NpgsqlCidr = NpgsqlCidr$instance;

export interface NpgsqlCircle$instance {
    center: NpgsqlPoint;
    radius: double;
    X: double;
    Y: double;
    deconstruct(x: double, y: double, radius: double): void;
    deconstruct(center: NpgsqlPoint, radius: double): void;
    equals(other: NpgsqlCircle): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlCircle: {
    new(x: double, y: double, radius: double): NpgsqlCircle;
    new(center: NpgsqlPoint, radius: double): NpgsqlCircle;
};


export type NpgsqlCircle = NpgsqlCircle$instance;

export interface NpgsqlCube$instance {
    readonly dimensions: int;
    readonly isPoint: boolean;
    readonly lowerLeft: IReadOnlyList<System_Internal.Double>;
    readonly upperRight: IReadOnlyList<System_Internal.Double>;
    equals(other: NpgsqlCube): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    toSubset(...indexes: int[]): NpgsqlCube;
}


export const NpgsqlCube: {
    new(coord: double): NpgsqlCube;
    new(lowerLeft: double, upperRight: double): NpgsqlCube;
    new(coords: IEnumerable__System_Collections_Generic<System_Internal.Double>): NpgsqlCube;
    new(lowerLeft: IEnumerable__System_Collections_Generic<System_Internal.Double>, upperRight: IEnumerable__System_Collections_Generic<System_Internal.Double>): NpgsqlCube;
    new(cube: NpgsqlCube, coord: double): NpgsqlCube;
    new(cube: NpgsqlCube, lowerLeft: double, upperRight: double): NpgsqlCube;
};


export type NpgsqlCube = NpgsqlCube$instance;

export interface NpgsqlInet$instance {
    readonly address: IPAddress;
    readonly netmask: byte;
    deconstruct(address: IPAddress, netmask: byte): void;
    equals(obj: unknown): boolean;
    equals(other: NpgsqlInet): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlInet: {
    new(address: IPAddress, netmask: byte): NpgsqlInet;
    new(address: IPAddress): NpgsqlInet;
    new(addr: string): NpgsqlInet;
};


export type NpgsqlInet = NpgsqlInet$instance;

export interface NpgsqlInterval$instance {
    readonly days: int;
    readonly months: int;
    readonly time: long;
    equals(other: NpgsqlInterval): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlInterval: {
    new(months: int, days: int, time: long): NpgsqlInterval;
};


export type NpgsqlInterval = NpgsqlInterval$instance;

export interface NpgsqlLine$instance {
    A: double;
    B: double;
    C: double;
    deconstruct(a: double, b: double, c: double): void;
    equals(other: NpgsqlLine): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlLine: {
    new(a: double, b: double, c: double): NpgsqlLine;
};


export type NpgsqlLine = NpgsqlLine$instance;

export interface NpgsqlLogSequenceNumber$instance {
    compareTo(value: NpgsqlLogSequenceNumber): int;
    equals(other: NpgsqlLogSequenceNumber): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlLogSequenceNumber: {
    new(value: ulong): NpgsqlLogSequenceNumber;
    readonly invalid: NpgsqlLogSequenceNumber;
    larger(value1: NpgsqlLogSequenceNumber, value2: NpgsqlLogSequenceNumber): NpgsqlLogSequenceNumber;
    parse(s: ReadOnlySpan<System_Internal.Char>): NpgsqlLogSequenceNumber;
    parse(s: string): NpgsqlLogSequenceNumber;
    smaller(value1: NpgsqlLogSequenceNumber, value2: NpgsqlLogSequenceNumber): NpgsqlLogSequenceNumber;
    tryParse(s: ReadOnlySpan<System_Internal.Char>, result: NpgsqlLogSequenceNumber): boolean;
    tryParse(s: string, result: NpgsqlLogSequenceNumber): boolean;
};


export type NpgsqlLogSequenceNumber = NpgsqlLogSequenceNumber$instance;

export interface NpgsqlLSeg$instance {
    end: NpgsqlPoint;
    start: NpgsqlPoint;
    deconstruct(start: NpgsqlPoint, end: NpgsqlPoint): void;
    equals(other: NpgsqlLSeg): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlLSeg: {
    new(start: NpgsqlPoint, end: NpgsqlPoint): NpgsqlLSeg;
    new(startx: double, starty: double, endx: double, endy: double): NpgsqlLSeg;
};


export type NpgsqlLSeg = NpgsqlLSeg$instance;

export interface NpgsqlPath$instance {
    readonly capacity: int;
    readonly count: int;
    readonly isReadOnly: boolean;
    item: NpgsqlPoint;
    open: boolean;
    add(item: NpgsqlPoint): void;
    clear(): void;
    contains(item: NpgsqlPoint): boolean;
    copyTo(array: NpgsqlPoint[], arrayIndex: int): void;
    equals(other: NpgsqlPath): boolean;
    equals(obj: unknown): boolean;
    getEnumerator(): IEnumerator<NpgsqlPoint>;
    getHashCode(): int;
    indexOf(item: NpgsqlPoint): int;
    insert(index: int, item: NpgsqlPoint): void;
    remove(item: NpgsqlPoint): boolean;
    removeAt(index: int): void;
    toString(): string;
}


export const NpgsqlPath: {
    new(): NpgsqlPath;
    new(points: IEnumerable__System_Collections_Generic<NpgsqlPoint>, open: boolean): NpgsqlPath;
    new(points: IEnumerable__System_Collections_Generic<NpgsqlPoint>): NpgsqlPath;
    new(points: NpgsqlPoint[]): NpgsqlPath;
    new(open: boolean): NpgsqlPath;
    new(capacity: int, open: boolean): NpgsqlPath;
    new(capacity: int): NpgsqlPath;
};


export type NpgsqlPath = NpgsqlPath$instance;

export interface NpgsqlPoint$instance {
    X: double;
    Y: double;
    deconstruct(x: double, y: double): void;
    equals(other: NpgsqlPoint): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlPoint: {
    new(x: double, y: double): NpgsqlPoint;
};


export type NpgsqlPoint = NpgsqlPoint$instance;

export interface NpgsqlPolygon$instance {
    readonly capacity: int;
    readonly count: int;
    readonly isReadOnly: boolean;
    item: NpgsqlPoint;
    add(item: NpgsqlPoint): void;
    clear(): void;
    contains(item: NpgsqlPoint): boolean;
    copyTo(array: NpgsqlPoint[], arrayIndex: int): void;
    equals(other: NpgsqlPolygon): boolean;
    equals(obj: unknown): boolean;
    getEnumerator(): IEnumerator<NpgsqlPoint>;
    getHashCode(): int;
    indexOf(item: NpgsqlPoint): int;
    insert(index: int, item: NpgsqlPoint): void;
    remove(item: NpgsqlPoint): boolean;
    removeAt(index: int): void;
    toString(): string;
}


export const NpgsqlPolygon: {
    new(): NpgsqlPolygon;
    new(points: IEnumerable__System_Collections_Generic<NpgsqlPoint>): NpgsqlPolygon;
    new(points: NpgsqlPoint[]): NpgsqlPolygon;
    new(capacity: int): NpgsqlPolygon;
};


export type NpgsqlPolygon = NpgsqlPolygon$instance;

export interface NpgsqlRange_1$instance<T> {
    readonly isEmpty: boolean;
    readonly lowerBound: T;
    readonly lowerBoundInfinite: boolean;
    readonly lowerBoundIsInclusive: boolean;
    readonly upperBound: T;
    readonly upperBoundInfinite: boolean;
    readonly upperBoundIsInclusive: boolean;
    equals(o: unknown): boolean;
    equals(other: NpgsqlRange_1<T>): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlRange_1: {
    new<T>(lowerBound: T, upperBound: T): NpgsqlRange_1<T>;
    new<T>(lowerBound: T, lowerBoundIsInclusive: boolean, upperBound: T, upperBoundIsInclusive: boolean): NpgsqlRange_1<T>;
    new<T>(lowerBound: T, lowerBoundIsInclusive: boolean, lowerBoundInfinite: boolean, upperBound: T, upperBoundIsInclusive: boolean, upperBoundInfinite: boolean): NpgsqlRange_1<T>;
    readonly empty: unknown;
    parse<T>(value: string): NpgsqlRange_1<T>;
};


export type NpgsqlRange_1<T> = NpgsqlRange_1$instance<T>;

export interface NpgsqlTid$instance {
    readonly blockNumber: uint;
    readonly offsetNumber: ushort;
    deconstruct(blockNumber: uint, offsetNumber: ushort): void;
    equals(other: NpgsqlTid): boolean;
    equals(o: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlTid: {
    new(blockNumber: uint, offsetNumber: ushort): NpgsqlTid;
};


export type NpgsqlTid = NpgsqlTid$instance;

export interface NpgsqlTsVector_Lexeme$instance {
    readonly count: int;
    readonly item: NpgsqlTsVector_Lexeme_WordEntryPos;
    text: string;
    equals(o: NpgsqlTsVector_Lexeme): boolean;
    equals(o: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlTsVector_Lexeme: {
    new(text: string): NpgsqlTsVector_Lexeme;
    new(text: string, wordEntryPositions: List<NpgsqlTsVector_Lexeme_WordEntryPos>): NpgsqlTsVector_Lexeme;
};


export type NpgsqlTsVector_Lexeme = NpgsqlTsVector_Lexeme$instance;

export interface NpgsqlTsVector_Lexeme_WordEntryPos$instance {
    readonly pos: int;
    readonly weight: NpgsqlTsVector_Lexeme_Weight;
    equals(o: NpgsqlTsVector_Lexeme_WordEntryPos): boolean;
    equals(o: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlTsVector_Lexeme_WordEntryPos: {
    new(pos: int, weight: NpgsqlTsVector_Lexeme_Weight): NpgsqlTsVector_Lexeme_WordEntryPos;
};


export type NpgsqlTsVector_Lexeme_WordEntryPos = NpgsqlTsVector_Lexeme_WordEntryPos$instance;

export interface NpgsqlRange_1_RangeTypeConverter$instance<T> extends TypeConverter {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown | undefined;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown | undefined;
}


export const NpgsqlRange_1_RangeTypeConverter: {
    new<T>(): NpgsqlRange_1_RangeTypeConverter<T>;
    register<T>(): void;
};


export type NpgsqlRange_1_RangeTypeConverter<T> = NpgsqlRange_1_RangeTypeConverter$instance<T>;

export interface NpgsqlTsQuery$instance {
    readonly kind: NpgsqlTsQuery_NodeKind;
    equals(obj: unknown): boolean;
    equals(other: NpgsqlTsQuery): boolean;
    getHashCode(): int;
    toString(): string;
    write(stringBuilder: StringBuilder): void;
}


export const NpgsqlTsQuery: {
    parse(value: string): NpgsqlTsQuery;
};


export type NpgsqlTsQuery = NpgsqlTsQuery$instance;

export interface NpgsqlTsQueryAnd$instance extends NpgsqlTsQueryBinOp {
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryAnd: {
    new(left: NpgsqlTsQuery, right: NpgsqlTsQuery): NpgsqlTsQueryAnd;
};


export type NpgsqlTsQueryAnd = NpgsqlTsQueryAnd$instance;

export interface NpgsqlTsQueryBinOp$instance extends NpgsqlTsQuery {
    left: NpgsqlTsQuery;
    right: NpgsqlTsQuery;
}


export const NpgsqlTsQueryBinOp: {
};


export type NpgsqlTsQueryBinOp = NpgsqlTsQueryBinOp$instance;

export interface NpgsqlTsQueryEmpty$instance extends NpgsqlTsQuery {
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryEmpty: {
    new(): NpgsqlTsQueryEmpty;
};


export type NpgsqlTsQueryEmpty = NpgsqlTsQueryEmpty$instance;

export interface NpgsqlTsQueryFollowedBy$instance extends NpgsqlTsQueryBinOp {
    distance: short;
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryFollowedBy: {
    new(left: NpgsqlTsQuery, distance: short, right: NpgsqlTsQuery): NpgsqlTsQueryFollowedBy;
};


export type NpgsqlTsQueryFollowedBy = NpgsqlTsQueryFollowedBy$instance;

export interface NpgsqlTsQueryLexeme$instance extends NpgsqlTsQuery {
    isPrefixSearch: boolean;
    text: string;
    weights: NpgsqlTsQueryLexeme_Weight;
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryLexeme: {
    new(text: string): NpgsqlTsQueryLexeme;
    new(text: string, weights: NpgsqlTsQueryLexeme_Weight): NpgsqlTsQueryLexeme;
    new(text: string, weights: NpgsqlTsQueryLexeme_Weight, isPrefixSearch: boolean): NpgsqlTsQueryLexeme;
};


export type NpgsqlTsQueryLexeme = NpgsqlTsQueryLexeme$instance;

export interface NpgsqlTsQueryNot$instance extends NpgsqlTsQuery {
    child: NpgsqlTsQuery;
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryNot: {
    new(child: NpgsqlTsQuery): NpgsqlTsQueryNot;
};


export type NpgsqlTsQueryNot = NpgsqlTsQueryNot$instance;

export interface NpgsqlTsQueryOr$instance extends NpgsqlTsQueryBinOp {
    equals(other: NpgsqlTsQuery): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const NpgsqlTsQueryOr: {
    new(left: NpgsqlTsQuery, right: NpgsqlTsQuery): NpgsqlTsQueryOr;
};


export type NpgsqlTsQueryOr = NpgsqlTsQueryOr$instance;

export interface NpgsqlTsVector$instance {
    readonly count: int;
    readonly item: NpgsqlTsVector_Lexeme;
    equals(other: NpgsqlTsVector): boolean;
    equals(obj: unknown): boolean;
    getEnumerator(): IEnumerator<NpgsqlTsVector_Lexeme>;
    getHashCode(): int;
    toString(): string;
}


export const NpgsqlTsVector: {
    new(): NpgsqlTsVector;
    readonly empty: NpgsqlTsVector;
    parse(value: string): NpgsqlTsVector;
};


export type NpgsqlTsVector = NpgsqlTsVector$instance;

export interface PgNameAttribute$instance extends Attribute {
    readonly pgName: string;
}


export const PgNameAttribute: {
    new(pgName: string): PgNameAttribute;
};


export type PgNameAttribute = PgNameAttribute$instance;

