// Generated by tsbindgen - Architecture
// Namespace: NpgsqlTypes
// Assembly: Npgsql

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyList_1, List_1 } from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections/internal/index.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, TypeConverter } from "@tsonic/dotnet/System.ComponentModel/internal/index.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization/internal/index.js";
import type { IPAddress } from "@tsonic/dotnet/System.Net/internal/index.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Char, Double, Enum, IComparable, IComparable_1, IConvertible, IEquatable_1, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, UInt16, UInt32, UInt64, ValueType, Void } from "@tsonic/dotnet/System/internal/index.js";

export enum NpgsqlDbType {
    Bigint = 1,
    Double = 8,
    Integer = 9,
    Numeric = 13,
    Real = 17,
    Smallint = 18,
    Money = 12,
    Boolean = 2,
    Box = 3,
    Circle = 5,
    Line = 10,
    LSeg = 11,
    Path = 14,
    Point = 15,
    Polygon = 16,
    Cube = 63,
    Char = 6,
    Text = 19,
    Varchar = 22,
    Name = 32,
    Citext = 51,
    InternalChar = 38,
    Bytea = 4,
    Date = 7,
    Time = 20,
    Timestamp = 21,
    TimestampTz = 26,
    Interval = 30,
    TimeTz = 31,
    Abstime = 33,
    Inet = 24,
    Cidr = 44,
    MacAddr = 34,
    MacAddr8 = 54,
    Bit = 25,
    Varbit = 39,
    TsVector = 45,
    TsQuery = 46,
    Regconfig = 56,
    Uuid = 27,
    Xml = 28,
    Json = 35,
    Jsonb = 36,
    JsonPath = 57,
    Hstore = 37,
    Refcursor = 23,
    Oidvector = 29,
    Int2Vector = 52,
    Oid = 41,
    Xid = 42,
    Xid8 = 64,
    Cid = 43,
    Regtype = 49,
    Tid = 53,
    PgLsn = 59,
    Unknown = 40,
    Geometry = 50,
    Geography = 55,
    LTree = 60,
    LQuery = 61,
    LTxtQuery = 62,
    IntegerRange = 1073741833,
    BigIntRange = 1073741825,
    NumericRange = 1073741837,
    TimestampRange = 1073741845,
    TimestampTzRange = 1073741850,
    DateRange = 1073741831,
    IntegerMultirange = 536870921,
    BigIntMultirange = 536870913,
    NumericMultirange = 536870925,
    TimestampMultirange = 536870933,
    TimestampTzMultirange = 536870938,
    DateMultirange = 536870919,
    Array = -2147483648,
    Range = 1073741824,
    Multirange = 536870912
}


export enum NpgsqlTsQuery_NodeKind {
    Empty = -1,
    Lexeme = 0,
    Not = 1,
    And = 2,
    Or = 3,
    Phrase = 4
}


export enum NpgsqlTsQueryLexeme_Weight {
    None = 0,
    D = 1,
    C = 2,
    B = 4,
    A = 8
}


export enum NpgsqlTsVector_Lexeme_Weight {
    D = 0,
    C = 1,
    B = 2,
    A = 3
}


export interface NpgsqlBox$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Bottom: double;
    readonly Height: double;
    readonly IsEmpty: boolean;
    readonly Left: double;
    LowerLeft: NpgsqlPoint;
    readonly Right: double;
    readonly Top: double;
    UpperRight: NpgsqlPoint;
    readonly Width: double;
    Deconstruct(lowerLeft: NpgsqlPoint, upperRight: NpgsqlPoint): void;
    Deconstruct(left: double, right: double, bottom: double, top: double): void;
    Deconstruct(left: double, right: double, bottom: double, top: double, width: double, height: double): void;
    Equals(other: NpgsqlBox): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlBox: {
    new(upperRight: NpgsqlPoint, lowerLeft: NpgsqlPoint): NpgsqlBox;
    new(top: double, right: double, bottom: double, left: double): NpgsqlBox;
};


export type NpgsqlBox = NpgsqlBox$instance;

export interface NpgsqlCidr$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Address: IPAddress;
    readonly Netmask: byte;
    Deconstruct(address: IPAddress, netmask: byte): void;
    Equals(obj: unknown): boolean;
    Equals(other: NpgsqlCidr): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlCidr: {
    new(address: IPAddress, netmask: byte): NpgsqlCidr;
    new(addr: string): NpgsqlCidr;
};


export type NpgsqlCidr = NpgsqlCidr$instance;

export interface NpgsqlCircle$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Center: NpgsqlPoint;
    Radius: double;
    X: double;
    Y: double;
    Deconstruct(x: double, y: double, radius: double): void;
    Deconstruct(center: NpgsqlPoint, radius: double): void;
    Equals(other: NpgsqlCircle): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlCircle: {
    new(x: double, y: double, radius: double): NpgsqlCircle;
    new(center: NpgsqlPoint, radius: double): NpgsqlCircle;
};


export type NpgsqlCircle = NpgsqlCircle$instance;

export interface NpgsqlCube$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Dimensions: int;
    readonly IsPoint: boolean;
    readonly LowerLeft: IReadOnlyList_1<System_Internal.Double>;
    readonly UpperRight: IReadOnlyList_1<System_Internal.Double>;
    Equals(other: NpgsqlCube): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToSubset(...indexes: int[]): NpgsqlCube;
}


export const NpgsqlCube: {
    new(coord: double): NpgsqlCube;
    new(lowerLeft: double, upperRight: double): NpgsqlCube;
    new(coords: IEnumerable_1<System_Internal.Double>): NpgsqlCube;
    new(lowerLeft: IEnumerable_1<System_Internal.Double>, upperRight: IEnumerable_1<System_Internal.Double>): NpgsqlCube;
    new(cube: NpgsqlCube, coord: double): NpgsqlCube;
    new(cube: NpgsqlCube, lowerLeft: double, upperRight: double): NpgsqlCube;
};


export type NpgsqlCube = NpgsqlCube$instance;

export interface NpgsqlInet$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Address: IPAddress;
    readonly Netmask: byte;
    Deconstruct(address: IPAddress, netmask: byte): void;
    Equals(obj: unknown): boolean;
    Equals(other: NpgsqlInet): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlInet: {
    new(address: IPAddress, netmask: byte): NpgsqlInet;
    new(address: IPAddress): NpgsqlInet;
    new(addr: string): NpgsqlInet;
};


export type NpgsqlInet = NpgsqlInet$instance;

export interface NpgsqlInterval$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Days: int;
    readonly Months: int;
    readonly Time: long;
    Equals(other: NpgsqlInterval): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlInterval: {
    new(months: int, days: int, time: long): NpgsqlInterval;
};


export type NpgsqlInterval = NpgsqlInterval$instance;

export interface NpgsqlLine$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    A: double;
    B: double;
    C: double;
    Deconstruct(a: double, b: double, c: double): void;
    Equals(other: NpgsqlLine): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlLine: {
    new(a: double, b: double, c: double): NpgsqlLine;
};


export type NpgsqlLine = NpgsqlLine$instance;

export interface NpgsqlLogSequenceNumber$instance {
    readonly __tsonic_iface_System_IComparable_1: never;
    readonly __tsonic_iface_System_IEquatable_1: never;

    CompareTo(value: NpgsqlLogSequenceNumber): int;
    Equals(other: NpgsqlLogSequenceNumber): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlLogSequenceNumber: {
    new(value: ulong): NpgsqlLogSequenceNumber;
    readonly Invalid: NpgsqlLogSequenceNumber;
    Larger(value1: NpgsqlLogSequenceNumber, value2: NpgsqlLogSequenceNumber): NpgsqlLogSequenceNumber;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>): NpgsqlLogSequenceNumber;
    Parse(s: string): NpgsqlLogSequenceNumber;
    Smaller(value1: NpgsqlLogSequenceNumber, value2: NpgsqlLogSequenceNumber): NpgsqlLogSequenceNumber;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, result: NpgsqlLogSequenceNumber): boolean;
    TryParse(s: string, result: NpgsqlLogSequenceNumber): boolean;
};


export type NpgsqlLogSequenceNumber = NpgsqlLogSequenceNumber$instance;

export interface NpgsqlLSeg$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    End: NpgsqlPoint;
    Start: NpgsqlPoint;
    Deconstruct(start: NpgsqlPoint, end: NpgsqlPoint): void;
    Equals(other: NpgsqlLSeg): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlLSeg: {
    new(start: NpgsqlPoint, end: NpgsqlPoint): NpgsqlLSeg;
    new(startx: double, starty: double, endx: double, endy: double): NpgsqlLSeg;
};


export type NpgsqlLSeg = NpgsqlLSeg$instance;

export interface NpgsqlPath$instance {
    readonly __tsonic_iface_System_Collections_Generic_ICollection_1: never;
    readonly __tsonic_iface_System_Collections_Generic_IEnumerable_1: never;
    readonly __tsonic_iface_System_Collections_Generic_IList_1: never;
    readonly __tsonic_iface_System_Collections_IEnumerable: never;
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Capacity: int;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    [index: number]: NpgsqlPoint;
    Open: boolean;
    Add(item: NpgsqlPoint): void;
    Clear(): void;
    Contains(item: NpgsqlPoint): boolean;
    CopyTo(array: NpgsqlPoint[], arrayIndex: int): void;
    Equals(other: NpgsqlPath): boolean;
    Equals(obj: unknown): boolean;
    GetEnumerator(): IEnumerator_1<NpgsqlPoint>;
    GetHashCode(): int;
    IndexOf(item: NpgsqlPoint): int;
    Insert(index: int, item: NpgsqlPoint): void;
    Remove(item: NpgsqlPoint): boolean;
    RemoveAt(index: int): void;
    ToString(): string;
}


export const NpgsqlPath: {
    new(): NpgsqlPath;
    new(points: IEnumerable_1<NpgsqlPoint>, open: boolean): NpgsqlPath;
    new(points: IEnumerable_1<NpgsqlPoint>): NpgsqlPath;
    new(points: NpgsqlPoint[]): NpgsqlPath;
    new(open: boolean): NpgsqlPath;
    new(capacity: int, open: boolean): NpgsqlPath;
    new(capacity: int): NpgsqlPath;
};


export type NpgsqlPath = NpgsqlPath$instance;

export interface NpgsqlPoint$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    X: double;
    Y: double;
    Deconstruct(x: double, y: double): void;
    Equals(other: NpgsqlPoint): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlPoint: {
    new(x: double, y: double): NpgsqlPoint;
};


export type NpgsqlPoint = NpgsqlPoint$instance;

export interface NpgsqlPolygon$instance {
    readonly __tsonic_iface_System_Collections_Generic_ICollection_1: never;
    readonly __tsonic_iface_System_Collections_Generic_IEnumerable_1: never;
    readonly __tsonic_iface_System_Collections_Generic_IList_1: never;
    readonly __tsonic_iface_System_Collections_IEnumerable: never;
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Capacity: int;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    [index: number]: NpgsqlPoint;
    Add(item: NpgsqlPoint): void;
    Clear(): void;
    Contains(item: NpgsqlPoint): boolean;
    CopyTo(array: NpgsqlPoint[], arrayIndex: int): void;
    Equals(other: NpgsqlPolygon): boolean;
    Equals(obj: unknown): boolean;
    GetEnumerator(): IEnumerator_1<NpgsqlPoint>;
    GetHashCode(): int;
    IndexOf(item: NpgsqlPoint): int;
    Insert(index: int, item: NpgsqlPoint): void;
    Remove(item: NpgsqlPoint): boolean;
    RemoveAt(index: int): void;
    ToString(): string;
}


export const NpgsqlPolygon: {
    new(): NpgsqlPolygon;
    new(points: IEnumerable_1<NpgsqlPoint>): NpgsqlPolygon;
    new(points: NpgsqlPoint[]): NpgsqlPolygon;
    new(capacity: int): NpgsqlPolygon;
};


export type NpgsqlPolygon = NpgsqlPolygon$instance;

export interface NpgsqlRange_1$instance<T> {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly IsEmpty: boolean;
    readonly LowerBound: T;
    readonly LowerBoundInfinite: boolean;
    readonly LowerBoundIsInclusive: boolean;
    readonly UpperBound: T;
    readonly UpperBoundInfinite: boolean;
    readonly UpperBoundIsInclusive: boolean;
    Equals(o: unknown): boolean;
    Equals(other: NpgsqlRange_1<T>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlRange_1: {
    new<T>(lowerBound: T, upperBound: T): NpgsqlRange_1<T>;
    new<T>(lowerBound: T, lowerBoundIsInclusive: boolean, upperBound: T, upperBoundIsInclusive: boolean): NpgsqlRange_1<T>;
    new<T>(lowerBound: T, lowerBoundIsInclusive: boolean, lowerBoundInfinite: boolean, upperBound: T, upperBoundIsInclusive: boolean, upperBoundInfinite: boolean): NpgsqlRange_1<T>;
    readonly Empty: unknown;
    Parse<T>(value: string): NpgsqlRange_1<T>;
};


export type NpgsqlRange_1<T> = NpgsqlRange_1$instance<T>;

export interface NpgsqlTid$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly BlockNumber: uint;
    readonly OffsetNumber: ushort;
    Deconstruct(blockNumber: uint, offsetNumber: ushort): void;
    Equals(other: NpgsqlTid): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlTid: {
    new(blockNumber: uint, offsetNumber: ushort): NpgsqlTid;
};


export type NpgsqlTid = NpgsqlTid$instance;

export interface NpgsqlTsVector_Lexeme$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Count: int;
    [index: number]: NpgsqlTsVector_Lexeme_WordEntryPos;
    Text: string;
    Equals(o: NpgsqlTsVector_Lexeme): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlTsVector_Lexeme: {
    new(text: string): NpgsqlTsVector_Lexeme;
    new(text: string, wordEntryPositions: List_1<NpgsqlTsVector_Lexeme_WordEntryPos>): NpgsqlTsVector_Lexeme;
};


export type NpgsqlTsVector_Lexeme = NpgsqlTsVector_Lexeme$instance;

export interface NpgsqlTsVector_Lexeme_WordEntryPos$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Pos: int;
    readonly Weight: NpgsqlTsVector_Lexeme_Weight;
    Equals(o: NpgsqlTsVector_Lexeme_WordEntryPos): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlTsVector_Lexeme_WordEntryPos: {
    new(pos: int, weight: NpgsqlTsVector_Lexeme_Weight): NpgsqlTsVector_Lexeme_WordEntryPos;
};


export type NpgsqlTsVector_Lexeme_WordEntryPos = NpgsqlTsVector_Lexeme_WordEntryPos$instance;

export interface NpgsqlRange_1_RangeTypeConverter$instance<T> extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown | undefined;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown | undefined;
}


export const NpgsqlRange_1_RangeTypeConverter: {
    new<T>(): NpgsqlRange_1_RangeTypeConverter<T>;
    Register<T>(): void;
};


export type NpgsqlRange_1_RangeTypeConverter<T> = NpgsqlRange_1_RangeTypeConverter$instance<T>;

export interface NpgsqlTsQuery$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Kind: NpgsqlTsQuery_NodeKind;
    Equals(obj: unknown): boolean;
    Equals(other: NpgsqlTsQuery): boolean;
    GetHashCode(): int;
    ToString(): string;
    Write(stringBuilder: StringBuilder): void;
}


export const NpgsqlTsQuery: (abstract new(kind: NpgsqlTsQuery_NodeKind) => NpgsqlTsQuery) & {
    Parse(value: string): NpgsqlTsQuery;
};


export type NpgsqlTsQuery = NpgsqlTsQuery$instance;

export interface NpgsqlTsQueryAnd$instance extends NpgsqlTsQueryBinOp {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryAnd: {
    new(left: NpgsqlTsQuery, right: NpgsqlTsQuery): NpgsqlTsQueryAnd;
};


export type NpgsqlTsQueryAnd = NpgsqlTsQueryAnd$instance;

export interface NpgsqlTsQueryBinOp$instance extends NpgsqlTsQuery {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Left: NpgsqlTsQuery;
    Right: NpgsqlTsQuery;
}


export const NpgsqlTsQueryBinOp: (abstract new(kind: NpgsqlTsQuery_NodeKind, left: NpgsqlTsQuery, right: NpgsqlTsQuery) => NpgsqlTsQueryBinOp) & {
};


export type NpgsqlTsQueryBinOp = NpgsqlTsQueryBinOp$instance;

export interface NpgsqlTsQueryEmpty$instance extends NpgsqlTsQuery {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryEmpty: {
    new(): NpgsqlTsQueryEmpty;
};


export type NpgsqlTsQueryEmpty = NpgsqlTsQueryEmpty$instance;

export interface NpgsqlTsQueryFollowedBy$instance extends NpgsqlTsQueryBinOp {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Distance: short;
    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryFollowedBy: {
    new(left: NpgsqlTsQuery, distance: short, right: NpgsqlTsQuery): NpgsqlTsQueryFollowedBy;
};


export type NpgsqlTsQueryFollowedBy = NpgsqlTsQueryFollowedBy$instance;

export interface NpgsqlTsQueryLexeme$instance extends NpgsqlTsQuery {
    readonly __tsonic_iface_System_IEquatable_1: never;

    IsPrefixSearch: boolean;
    Text: string;
    Weights: NpgsqlTsQueryLexeme_Weight;
    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryLexeme: {
    new(text: string): NpgsqlTsQueryLexeme;
    new(text: string, weights: NpgsqlTsQueryLexeme_Weight): NpgsqlTsQueryLexeme;
    new(text: string, weights: NpgsqlTsQueryLexeme_Weight, isPrefixSearch: boolean): NpgsqlTsQueryLexeme;
};


export type NpgsqlTsQueryLexeme = NpgsqlTsQueryLexeme$instance;

export interface NpgsqlTsQueryNot$instance extends NpgsqlTsQuery {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Child: NpgsqlTsQuery;
    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryNot: {
    new(child: NpgsqlTsQuery): NpgsqlTsQueryNot;
};


export type NpgsqlTsQueryNot = NpgsqlTsQueryNot$instance;

export interface NpgsqlTsQueryOr$instance extends NpgsqlTsQueryBinOp {
    readonly __tsonic_iface_System_IEquatable_1: never;

    Equals(other: NpgsqlTsQuery): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const NpgsqlTsQueryOr: {
    new(left: NpgsqlTsQuery, right: NpgsqlTsQuery): NpgsqlTsQueryOr;
};


export type NpgsqlTsQueryOr = NpgsqlTsQueryOr$instance;

export interface NpgsqlTsVector$instance {
    readonly __tsonic_iface_System_Collections_Generic_IEnumerable_1: never;
    readonly __tsonic_iface_System_Collections_IEnumerable: never;
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Count: int;
    readonly [index: number]: NpgsqlTsVector_Lexeme;
    Equals(other: NpgsqlTsVector): boolean;
    Equals(obj: unknown): boolean;
    GetEnumerator(): IEnumerator_1<NpgsqlTsVector_Lexeme>;
    GetHashCode(): int;
    ToString(): string;
}


export const NpgsqlTsVector: {
    readonly Empty: NpgsqlTsVector;
    Parse(value: string): NpgsqlTsVector;
};


export type NpgsqlTsVector = NpgsqlTsVector$instance;

export interface PgNameAttribute$instance extends Attribute {
    readonly PgName: string;
}


export const PgNameAttribute: {
    new(pgName: string): PgNameAttribute;
};


export type PgNameAttribute = PgNameAttribute$instance;

